// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// SmbShare smb share
// swagger:model SmbShare
type SmbShare struct {

	// Only enumerate files and folders the requesting user has access to.
	AccessBasedEnumeration bool `json:"access_based_enumeration,omitempty"`

	// Access-based enumeration on only the root directory of the share.
	AccessBasedEnumerationRootOnly bool `json:"access_based_enumeration_root_only,omitempty"`

	// Allow deletion of read-only files in the share.
	AllowDeleteReadonly bool `json:"allow_delete_readonly,omitempty"`

	// Allows users to execute files they have read rights for.
	AllowExecuteAlways bool `json:"allow_execute_always,omitempty"`

	// Allow automatic expansion of variables for home directories.
	AllowVariableExpansion bool `json:"allow_variable_expansion,omitempty"`

	// Automatically create home directories.
	AutoCreateDirectory bool `json:"auto_create_directory,omitempty"`

	// Share is visible in net view and the browse list.
	Browsable bool `json:"browsable,omitempty"`

	// Persistent open timeout for the share.
	// Minimum: 2
	CaTimeout int64 `json:"ca_timeout,omitempty"`

	// Specify the level of write-integrity on continuously available shares.
	CaWriteIntegrity string `json:"ca_write_integrity,omitempty"`

	// Level of change notification alerts on the share.
	ChangeNotify string `json:"change_notify,omitempty"`

	// Create permissions for new files and directories in share.
	CreatePermissions string `json:"create_permissions,omitempty"`

	// Client-side caching policy for the shares.
	CscPolicy string `json:"csc_policy,omitempty"`

	// Description for this SMB share.
	Description string `json:"description,omitempty"`

	// Directory create mask bits.
	DirectoryCreateMask int64 `json:"directory_create_mask,omitempty"`

	// Directory create mode bits.
	DirectoryCreateMode int64 `json:"directory_create_mode,omitempty"`

	// File create mask bits.
	FileCreateMask int64 `json:"file_create_mask,omitempty"`

	// File create mode bits.
	FileCreateMode int64 `json:"file_create_mode,omitempty"`

	// Specifies the list of file extensions.
	FileFilterExtensions []string `json:"file_filter_extensions"`

	// Specifies if filter list is for deny or allow. Default is deny.
	FileFilterType string `json:"file_filter_type,omitempty"`

	// Enables file filtering on this zone.
	FileFilteringEnabled bool `json:"file_filtering_enabled,omitempty"`

	// Hide files and directories that begin with a period '.'.
	HideDotFiles bool `json:"hide_dot_files,omitempty"`

	// An ACL expressing which hosts are allowed access. A deny clause must be the final entry.
	HostACL []string `json:"host_acl"`

	// Specify the condition in which user access is done as the guest account.
	ImpersonateGuest string `json:"impersonate_guest,omitempty"`

	// User account to be used as guest account.
	ImpersonateUser string `json:"impersonate_user,omitempty"`

	// Set the inheritable ACL on the share path.
	InheritablePathACL bool `json:"inheritable_path_acl,omitempty"`

	// Specifies the wchar_t starting point for automatic byte mangling.
	MangleByteStart int64 `json:"mangle_byte_start,omitempty"`

	// Character mangle map.
	MangleMap []string `json:"mangle_map"`

	// Share name.
	Name string `json:"name,omitempty"`

	// Support NTFS ACLs on files and directories.
	NtfsACLSupport bool `json:"ntfs_acl_support,omitempty"`

	// Support oplocks.
	Oplocks bool `json:"oplocks,omitempty"`

	// Path of share within /ifs.
	Path string `json:"path,omitempty"`

	// Specifies an ordered list of permission modifications.
	Permissions []*SmbSharePermission `json:"permissions"`

	// Allow account to run as root.
	RunAsRoot []*GroupMember `json:"run_as_root"`

	// Specifies if persistent opens would do strict lockout on the share.
	StrictCaLockout bool `json:"strict_ca_lockout,omitempty"`

	// Handle SMB flush operations.
	StrictFlush bool `json:"strict_flush,omitempty"`

	// Specifies whether byte range locks contend against SMB I/O.
	StrictLocking bool `json:"strict_locking,omitempty"`

	// Name of the access zone to which to move this SMB share
	Zone string `json:"zone,omitempty"`
}

// Validate validates this smb share
func (m *SmbShare) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCaTimeout(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePermissions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRunAsRoot(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SmbShare) validateCaTimeout(formats strfmt.Registry) error {

	if swag.IsZero(m.CaTimeout) { // not required
		return nil
	}

	if err := validate.MinimumInt("ca_timeout", "body", int64(m.CaTimeout), 2, false); err != nil {
		return err
	}

	return nil
}

func (m *SmbShare) validatePermissions(formats strfmt.Registry) error {

	if swag.IsZero(m.Permissions) { // not required
		return nil
	}

	for i := 0; i < len(m.Permissions); i++ {
		if swag.IsZero(m.Permissions[i]) { // not required
			continue
		}

		if m.Permissions[i] != nil {
			if err := m.Permissions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("permissions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *SmbShare) validateRunAsRoot(formats strfmt.Registry) error {

	if swag.IsZero(m.RunAsRoot) { // not required
		return nil
	}

	for i := 0; i < len(m.RunAsRoot); i++ {
		if swag.IsZero(m.RunAsRoot[i]) { // not required
			continue
		}

		if m.RunAsRoot[i] != nil {
			if err := m.RunAsRoot[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("run_as_root" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *SmbShare) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SmbShare) UnmarshalBinary(b []byte) error {
	var res SmbShare
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
