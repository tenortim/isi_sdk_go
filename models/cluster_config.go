// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ClusterConfig cluster config
// swagger:model ClusterConfig
type ClusterConfig struct {

	// Customer configurable description.
	// Required: true
	Description *string `json:"description"`

	// devices
	// Required: true
	Devices []*ClusterConfigDevice `json:"devices"`

	// Default encoding.
	// Required: true
	Encoding *string `json:"encoding"`

	// Cluster GUID.
	// Required: true
	GUID *string `json:"guid"`

	// If true, the local node is in a group with quorum: It is communicating, storing, and protecting data normally with other nodes in its group.  Under normal circumstances, every node in the cluster is part of one group.
	// Required: true
	HasQuorum *bool `json:"has_quorum"`

	// If true, the cluster is in compliance mode.  Compliance mode clusters do not allow root access and have stricter WORM (Write Once Read Many) features for retaining data in compliance with U.S. Securities and Exchange Commission rule 17a-4.
	// Required: true
	IsCompliance *bool `json:"is_compliance"`

	// true if the cluster is deployed on a desktop VMWorkstation
	// Required: true
	IsVirtual *bool `json:"is_virtual"`

	// true if this is a vOneFS cluster on an ESXi
	// Required: true
	IsVonefs *bool `json:"is_vonefs"`

	// Node join mode: 'manual' or 'secure'.
	// Required: true
	JoinMode *string `json:"join_mode"`

	// Device ID of the queried node.
	// Required: true
	LocalDevid *int64 `json:"local_devid"`

	// Device logical node number of the queried node.
	// Required: true
	LocalLnn *int64 `json:"local_lnn"`

	// Device serial number of the queried node.
	// Required: true
	LocalSerial *string `json:"local_serial"`

	// Cluster name.
	// Required: true
	Name *string `json:"name"`

	// onefs version
	OnefsVersion *ClusterConfigOnefsVersion `json:"onefs_version,omitempty"`

	// The cluster timezone settings.
	Timezone *ClusterConfigTimezone `json:"timezone,omitempty"`

	// upgrade type
	UpgradeType string `json:"upgrade_type,omitempty"`
}

// Validate validates this cluster config
func (m *ClusterConfig) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDescription(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDevices(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEncoding(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGUID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHasQuorum(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsCompliance(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsVirtual(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIsVonefs(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateJoinMode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLocalDevid(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLocalLnn(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLocalSerial(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOnefsVersion(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimezone(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterConfig) validateDescription(formats strfmt.Registry) error {

	if err := validate.Required("description", "body", m.Description); err != nil {
		return err
	}

	return nil
}

func (m *ClusterConfig) validateDevices(formats strfmt.Registry) error {

	if err := validate.Required("devices", "body", m.Devices); err != nil {
		return err
	}

	for i := 0; i < len(m.Devices); i++ {
		if swag.IsZero(m.Devices[i]) { // not required
			continue
		}

		if m.Devices[i] != nil {
			if err := m.Devices[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("devices" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ClusterConfig) validateEncoding(formats strfmt.Registry) error {

	if err := validate.Required("encoding", "body", m.Encoding); err != nil {
		return err
	}

	return nil
}

func (m *ClusterConfig) validateGUID(formats strfmt.Registry) error {

	if err := validate.Required("guid", "body", m.GUID); err != nil {
		return err
	}

	return nil
}

func (m *ClusterConfig) validateHasQuorum(formats strfmt.Registry) error {

	if err := validate.Required("has_quorum", "body", m.HasQuorum); err != nil {
		return err
	}

	return nil
}

func (m *ClusterConfig) validateIsCompliance(formats strfmt.Registry) error {

	if err := validate.Required("is_compliance", "body", m.IsCompliance); err != nil {
		return err
	}

	return nil
}

func (m *ClusterConfig) validateIsVirtual(formats strfmt.Registry) error {

	if err := validate.Required("is_virtual", "body", m.IsVirtual); err != nil {
		return err
	}

	return nil
}

func (m *ClusterConfig) validateIsVonefs(formats strfmt.Registry) error {

	if err := validate.Required("is_vonefs", "body", m.IsVonefs); err != nil {
		return err
	}

	return nil
}

func (m *ClusterConfig) validateJoinMode(formats strfmt.Registry) error {

	if err := validate.Required("join_mode", "body", m.JoinMode); err != nil {
		return err
	}

	return nil
}

func (m *ClusterConfig) validateLocalDevid(formats strfmt.Registry) error {

	if err := validate.Required("local_devid", "body", m.LocalDevid); err != nil {
		return err
	}

	return nil
}

func (m *ClusterConfig) validateLocalLnn(formats strfmt.Registry) error {

	if err := validate.Required("local_lnn", "body", m.LocalLnn); err != nil {
		return err
	}

	return nil
}

func (m *ClusterConfig) validateLocalSerial(formats strfmt.Registry) error {

	if err := validate.Required("local_serial", "body", m.LocalSerial); err != nil {
		return err
	}

	return nil
}

func (m *ClusterConfig) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *ClusterConfig) validateOnefsVersion(formats strfmt.Registry) error {

	if swag.IsZero(m.OnefsVersion) { // not required
		return nil
	}

	if m.OnefsVersion != nil {
		if err := m.OnefsVersion.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("onefs_version")
			}
			return err
		}
	}

	return nil
}

func (m *ClusterConfig) validateTimezone(formats strfmt.Registry) error {

	if swag.IsZero(m.Timezone) { // not required
		return nil
	}

	if m.Timezone != nil {
		if err := m.Timezone.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("timezone")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterConfig) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterConfig) UnmarshalBinary(b []byte) error {
	var res ClusterConfig
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
