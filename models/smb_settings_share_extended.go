// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// SmbSettingsShareExtended smb settings share extended
// swagger:model SmbSettingsShareExtended
type SmbSettingsShareExtended struct {

	// Only enumerate files and folders the requesting user has access to.
	AccessBasedEnumeration bool `json:"access_based_enumeration,omitempty"`

	// Access-based enumeration on only the root directory of the share.
	AccessBasedEnumerationRootOnly bool `json:"access_based_enumeration_root_only,omitempty"`

	// Allow deletion of read-only files in the share.
	AllowDeleteReadonly bool `json:"allow_delete_readonly,omitempty"`

	// Allows users to execute files they have read rights for.
	AllowExecuteAlways bool `json:"allow_execute_always,omitempty"`

	// Persistent open timeout for the share.
	// Minimum: 2
	CaTimeout int64 `json:"ca_timeout,omitempty"`

	// Specify the level of write-integrity on continuously available shares.
	CaWriteIntegrity string `json:"ca_write_integrity,omitempty"`

	// Specify level of change notification alerts on the share.
	ChangeNotify string `json:"change_notify,omitempty"`

	// Set the create permissions for new files and directories in share.
	CreatePermissions string `json:"create_permissions,omitempty"`

	// Client-side caching policy for the shares.
	CscPolicy string `json:"csc_policy,omitempty"`

	// Unix umask or mode bits.
	// Maximum: 511
	// Minimum: 0
	DirectoryCreateMask *int64 `json:"directory_create_mask,omitempty"`

	// Unix umask or mode bits.
	// Maximum: 511
	// Minimum: 0
	DirectoryCreateMode *int64 `json:"directory_create_mode,omitempty"`

	// Unix umask or mode bits.
	// Maximum: 511
	// Minimum: 0
	FileCreateMask *int64 `json:"file_create_mask,omitempty"`

	// Unix umask or mode bits.
	// Maximum: 511
	// Minimum: 0
	FileCreateMode *int64 `json:"file_create_mode,omitempty"`

	// Specifies the list of file extensions.
	FileFilterExtensions []string `json:"file_filter_extensions"`

	// Specifies if filter list is for deny or allow. Default is deny.
	FileFilterType string `json:"file_filter_type,omitempty"`

	// Enables file filtering on the share.
	FileFilteringEnabled bool `json:"file_filtering_enabled,omitempty"`

	// Hide files and directories that begin with a period '.'.
	HideDotFiles bool `json:"hide_dot_files,omitempty"`

	// An ACL expressing which hosts are allowed access. A deny clause must be the final entry.
	HostACL []string `json:"host_acl"`

	// Specify the condition in which user access is done as the guest account.
	ImpersonateGuest string `json:"impersonate_guest,omitempty"`

	// User account to be used as guest account.
	ImpersonateUser string `json:"impersonate_user,omitempty"`

	// Specifies the wchar_t starting point for automatic byte mangling.
	// Maximum: 65535
	// Minimum: 256
	MangleByteStart int64 `json:"mangle_byte_start,omitempty"`

	// Character mangle map.
	MangleMap []string `json:"mangle_map"`

	// Support NTFS ACLs on files and directories.
	NtfsACLSupport bool `json:"ntfs_acl_support,omitempty"`

	// Allow oplock requests.
	Oplocks bool `json:"oplocks,omitempty"`

	// Specifies if persistent opens would do strict lockout on the share.
	StrictCaLockout bool `json:"strict_ca_lockout,omitempty"`

	// Handle SMB flush operations.
	StrictFlush bool `json:"strict_flush,omitempty"`

	// Specifies whether byte range locks contend against SMB I/O.
	StrictLocking bool `json:"strict_locking,omitempty"`

	// Name of the access zone in which to update settings
	Zone string `json:"zone,omitempty"`
}

// Validate validates this smb settings share extended
func (m *SmbSettingsShareExtended) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCaTimeout(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDirectoryCreateMask(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDirectoryCreateMode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFileCreateMask(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFileCreateMode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMangleByteStart(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SmbSettingsShareExtended) validateCaTimeout(formats strfmt.Registry) error {

	if swag.IsZero(m.CaTimeout) { // not required
		return nil
	}

	if err := validate.MinimumInt("ca_timeout", "body", int64(m.CaTimeout), 2, false); err != nil {
		return err
	}

	return nil
}

func (m *SmbSettingsShareExtended) validateDirectoryCreateMask(formats strfmt.Registry) error {

	if swag.IsZero(m.DirectoryCreateMask) { // not required
		return nil
	}

	if err := validate.MinimumInt("directory_create_mask", "body", int64(*m.DirectoryCreateMask), 0, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("directory_create_mask", "body", int64(*m.DirectoryCreateMask), 511, false); err != nil {
		return err
	}

	return nil
}

func (m *SmbSettingsShareExtended) validateDirectoryCreateMode(formats strfmt.Registry) error {

	if swag.IsZero(m.DirectoryCreateMode) { // not required
		return nil
	}

	if err := validate.MinimumInt("directory_create_mode", "body", int64(*m.DirectoryCreateMode), 0, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("directory_create_mode", "body", int64(*m.DirectoryCreateMode), 511, false); err != nil {
		return err
	}

	return nil
}

func (m *SmbSettingsShareExtended) validateFileCreateMask(formats strfmt.Registry) error {

	if swag.IsZero(m.FileCreateMask) { // not required
		return nil
	}

	if err := validate.MinimumInt("file_create_mask", "body", int64(*m.FileCreateMask), 0, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("file_create_mask", "body", int64(*m.FileCreateMask), 511, false); err != nil {
		return err
	}

	return nil
}

func (m *SmbSettingsShareExtended) validateFileCreateMode(formats strfmt.Registry) error {

	if swag.IsZero(m.FileCreateMode) { // not required
		return nil
	}

	if err := validate.MinimumInt("file_create_mode", "body", int64(*m.FileCreateMode), 0, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("file_create_mode", "body", int64(*m.FileCreateMode), 511, false); err != nil {
		return err
	}

	return nil
}

func (m *SmbSettingsShareExtended) validateMangleByteStart(formats strfmt.Registry) error {

	if swag.IsZero(m.MangleByteStart) { // not required
		return nil
	}

	if err := validate.MinimumInt("mangle_byte_start", "body", int64(m.MangleByteStart), 256, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("mangle_byte_start", "body", int64(m.MangleByteStart), 65535, false); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SmbSettingsShareExtended) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SmbSettingsShareExtended) UnmarshalBinary(b []byte) error {
	var res SmbSettingsShareExtended
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
