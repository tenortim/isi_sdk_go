// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ReportSubreport report subreport
// swagger:model ReportSubreport
type ReportSubreport struct {

	// The action to be taken by this job.
	// Required: true
	// Enum: [resync_prep allow_write allow_write_revert test run]
	Action *string `json:"action"`

	// The number of ads streams replicated by this job.
	// Required: true
	AdsStreamsReplicated *int64 `json:"ads_streams_replicated"`

	// The number of block specs replicated by this job.
	// Required: true
	BlockSpecsReplicated *int64 `json:"block_specs_replicated"`

	// The number of bytes recoverable by this job.
	// Required: true
	BytesRecoverable *int64 `json:"bytes_recoverable"`

	// The number of bytes that have been transferred by this job.
	// Required: true
	BytesTransferred *int64 `json:"bytes_transferred"`

	// The number of char specs replicated by this job.
	// Required: true
	CharSpecsReplicated *int64 `json:"char_specs_replicated"`

	// The number of LINs corrected by this job.
	// Required: true
	CorrectedLins *int64 `json:"corrected_lins"`

	// This field is true if the node running this job is dead.
	// Required: true
	DeadNode *bool `json:"dead_node"`

	// The number of directories replicated.
	// Required: true
	DirectoriesReplicated *int64 `json:"directories_replicated"`

	// The number of directories changed by this job.
	// Required: true
	DirsChanged *int64 `json:"dirs_changed"`

	// The number of directories deleted by this job.
	// Required: true
	DirsDeleted *int64 `json:"dirs_deleted"`

	// The number of directories moved by this job.
	// Required: true
	DirsMoved *int64 `json:"dirs_moved"`

	// The number of directories created by this job.
	// Required: true
	DirsNew *int64 `json:"dirs_new"`

	// The amount of time in seconds between when the job was started and when it ended.  If the job has not yet ended, this is the amount of time since the job started.  This field is null if the job has not yet started.
	Duration int64 `json:"duration,omitempty"`

	// The time the job ended in unix epoch seconds. The field is null if the job hasn't ended.
	EndTime int64 `json:"end_time,omitempty"`

	// The primary error message for this job.
	// Required: true
	Error *string `json:"error"`

	// The number of files with checksum errors skipped by this job.
	// Required: true
	ErrorChecksumFilesSkipped *int64 `json:"error_checksum_files_skipped"`

	// The number of files with io errors skipped by this job.
	// Required: true
	ErrorIoFilesSkipped *int64 `json:"error_io_files_skipped"`

	// The number of files with network errors skipped by this job.
	// Required: true
	ErrorNetFilesSkipped *int64 `json:"error_net_files_skipped"`

	// A list of error messages for this job.
	// Required: true
	Errors []string `json:"errors"`

	// Tyhe number of data chunks that failed transmission.
	// Required: true
	FailedChunks *int64 `json:"failed_chunks"`

	// The number of fifos replicated by this job.
	// Required: true
	FifosReplicated *int64 `json:"fifos_replicated"`

	// The number of bytes transferred that belong to files.
	// Required: true
	FileDataBytes *int64 `json:"file_data_bytes"`

	// The number of files changed by this job.
	// Required: true
	FilesChanged *int64 `json:"files_changed"`

	// The number of files linked by this job.
	// Required: true
	FilesLinked *int64 `json:"files_linked"`

	// The number of files created by this job.
	// Required: true
	FilesNew *int64 `json:"files_new"`

	// The number of files selected by this job.
	// Required: true
	FilesSelected *int64 `json:"files_selected"`

	// The number of files transferred by this job.
	// Required: true
	FilesTransferred *int64 `json:"files_transferred"`

	// The number of files unlinked by this job.
	// Required: true
	FilesUnlinked *int64 `json:"files_unlinked"`

	// The number of files with ads replicated by this job.
	// Required: true
	FilesWithAdsReplicated *int64 `json:"files_with_ads_replicated"`

	// The number of LINs flipped by this job.
	// Required: true
	FlippedLins *int64 `json:"flipped_lins"`

	// The number of hard links replicated by this job.
	// Required: true
	HardLinksReplicated *int64 `json:"hard_links_replicated"`

	// The number of hash exceptions fixed by this job.
	// Required: true
	HashExceptionsFixed *int64 `json:"hash_exceptions_fixed"`

	// The number of hash exceptions found by this job.
	// Required: true
	HashExceptionsFound *int64 `json:"hash_exceptions_found"`

	// A unique identifier for this object.
	// Required: true
	ID *string `json:"id"`

	// The ID of the job.
	JobID int64 `json:"job_id,omitempty"`

	// The number of LINs transferred by this job.
	// Required: true
	LinsTotal *int64 `json:"lins_total"`

	// The total number of bytes sent to the source by this job.
	// Required: true
	NetworkBytesToSource *int64 `json:"network_bytes_to_source"`

	// The total number of bytes sent to the target by this job.
	// Required: true
	NetworkBytesToTarget *int64 `json:"network_bytes_to_target"`

	// The number of new files replicated by this job.
	// Required: true
	NewFilesReplicated *int64 `json:"new_files_replicated"`

	// The number of files that have been retransmitted by this job.
	// Required: true
	NumRetransmittedFiles *int64 `json:"num_retransmitted_files"`

	// Data for each phase of this job.
	// Required: true
	Phases []*ReportSubreportPhase `json:"phases"`

	// policy
	// Required: true
	Policy *ReportSubreportPolicy `json:"policy"`

	// This is the action the policy is configured to perform.
	// Required: true
	// Enum: [copy sync]
	PolicyAction *string `json:"policy_action"`

	// The ID of the policy.
	// Required: true
	PolicyID *string `json:"policy_id"`

	// The name of the policy.
	// Required: true
	PolicyName *string `json:"policy_name"`

	// The number of regular files replicated by this job.
	// Required: true
	RegularFilesReplicated *int64 `json:"regular_files_replicated"`

	// The number of LINs resynched by this job.
	// Required: true
	ResyncedLins *int64 `json:"resynced_lins"`

	// The files that have been retransmitted by this job.
	// Required: true
	RetransmittedFiles []string `json:"retransmitted_files"`

	// The number of times the job has been retried.
	// Required: true
	Retry *int64 `json:"retry"`

	// The number of data chunks currently being transmitted.
	// Required: true
	RunningChunks *int64 `json:"running_chunks"`

	// The number of sockets replicated by this job.
	// Required: true
	SocketsReplicated *int64 `json:"sockets_replicated"`

	// The number of bytes recovered on the source.
	// Required: true
	SourceBytesRecovered *int64 `json:"source_bytes_recovered"`

	// The number of directories created on the source.
	// Required: true
	SourceDirectoriesCreated *int64 `json:"source_directories_created"`

	// The number of directories deleted on the source.
	// Required: true
	SourceDirectoriesDeleted *int64 `json:"source_directories_deleted"`

	// The number of directories linked on the source.
	// Required: true
	SourceDirectoriesLinked *int64 `json:"source_directories_linked"`

	// The number of directories unlinked on the source.
	// Required: true
	SourceDirectoriesUnlinked *int64 `json:"source_directories_unlinked"`

	// The number of directories visited on the source.
	// Required: true
	SourceDirectoriesVisited *int64 `json:"source_directories_visited"`

	// The number of files deleted on the source.
	// Required: true
	SourceFilesDeleted *int64 `json:"source_files_deleted"`

	// The number of files linked on the source.
	// Required: true
	SourceFilesLinked *int64 `json:"source_files_linked"`

	// The number of files unlinked on the source.
	// Required: true
	SourceFilesUnlinked *int64 `json:"source_files_unlinked"`

	// The number of sparse data bytes transferred by this job.
	// Required: true
	SparseDataBytes *int64 `json:"sparse_data_bytes"`

	// The time the job started in unix epoch seconds. The field is null if the job hasn't started.
	StartTime int64 `json:"start_time,omitempty"`

	// The state of the job.
	// Required: true
	// Enum: [scheduled running paused finished failed canceled needs_attention skipped pending unknown]
	State *string `json:"state"`

	// The number of data chunks that have been transmitted successfully.
	// Required: true
	SucceededChunks *int64 `json:"succeeded_chunks"`

	// The number of symlinks replicated by this job.
	// Required: true
	SymlinksReplicated *int64 `json:"symlinks_replicated"`

	// The type of sync being performed by this job.
	// Required: true
	// Enum: [invalid legacy initial incremental upgrade fofb domainmark]
	SyncType *string `json:"sync_type"`

	// The number of bytes recovered on the target.
	// Required: true
	TargetBytesRecovered *int64 `json:"target_bytes_recovered"`

	// The number of directories created on the target.
	// Required: true
	TargetDirectoriesCreated *int64 `json:"target_directories_created"`

	// The number of directories deleted on the target.
	// Required: true
	TargetDirectoriesDeleted *int64 `json:"target_directories_deleted"`

	// The number of directories linked on the target.
	// Required: true
	TargetDirectoriesLinked *int64 `json:"target_directories_linked"`

	// The number of directories unlinked on the target.
	// Required: true
	TargetDirectoriesUnlinked *int64 `json:"target_directories_unlinked"`

	// The number of files deleted on the target.
	// Required: true
	TargetFilesDeleted *int64 `json:"target_files_deleted"`

	// The number of files linked on the target.
	// Required: true
	TargetFilesLinked *int64 `json:"target_files_linked"`

	// The number of files unlinked on the target.
	// Required: true
	TargetFilesUnlinked *int64 `json:"target_files_unlinked"`

	// The target snapshots created by this job.
	// Required: true
	TargetSnapshots []string `json:"target_snapshots"`

	// The total number of data chunks transmitted by this job.
	// Required: true
	TotalChunks *int64 `json:"total_chunks"`

	// The total number of bytes transferred by this job.
	// Required: true
	TotalDataBytes *int64 `json:"total_data_bytes"`

	// The number of files affected by this job.
	// Required: true
	TotalFiles *int64 `json:"total_files"`

	// The total number of bytes sent over the network by this job.
	// Required: true
	TotalNetworkBytes *int64 `json:"total_network_bytes"`

	// The total number of phases for this job.
	// Required: true
	TotalPhases *int64 `json:"total_phases"`

	// The number of bytes unchanged by this job.
	// Required: true
	UnchangedDataBytes *int64 `json:"unchanged_data_bytes"`

	// The number of up-to-date files skipped by this job.
	// Required: true
	UpToDateFilesSkipped *int64 `json:"up_to_date_files_skipped"`

	// The number of updated files replicated by this job.
	// Required: true
	UpdatedFilesReplicated *int64 `json:"updated_files_replicated"`

	// The number of files with user conflicts skipped by this job.
	// Required: true
	UserConflictFilesSkipped *int64 `json:"user_conflict_files_skipped"`

	// A list of warning messages for this job.
	// Required: true
	Warnings []string `json:"warnings"`
}

// Validate validates this report subreport
func (m *ReportSubreport) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAction(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAdsStreamsReplicated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBlockSpecsReplicated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBytesRecoverable(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBytesTransferred(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCharSpecsReplicated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCorrectedLins(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDeadNode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDirectoriesReplicated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDirsChanged(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDirsDeleted(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDirsMoved(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDirsNew(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateError(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateErrorChecksumFilesSkipped(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateErrorIoFilesSkipped(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateErrorNetFilesSkipped(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateErrors(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFailedChunks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFifosReplicated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFileDataBytes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFilesChanged(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFilesLinked(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFilesNew(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFilesSelected(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFilesTransferred(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFilesUnlinked(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFilesWithAdsReplicated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFlippedLins(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHardLinksReplicated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHashExceptionsFixed(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHashExceptionsFound(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLinsTotal(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNetworkBytesToSource(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNetworkBytesToTarget(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNewFilesReplicated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNumRetransmittedFiles(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePhases(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePolicyAction(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePolicyID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePolicyName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRegularFilesReplicated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResyncedLins(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRetransmittedFiles(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRetry(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRunningChunks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSocketsReplicated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourceBytesRecovered(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourceDirectoriesCreated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourceDirectoriesDeleted(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourceDirectoriesLinked(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourceDirectoriesUnlinked(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourceDirectoriesVisited(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourceFilesDeleted(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourceFilesLinked(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourceFilesUnlinked(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSparseDataBytes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSucceededChunks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSymlinksReplicated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSyncType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTargetBytesRecovered(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTargetDirectoriesCreated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTargetDirectoriesDeleted(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTargetDirectoriesLinked(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTargetDirectoriesUnlinked(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTargetFilesDeleted(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTargetFilesLinked(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTargetFilesUnlinked(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTargetSnapshots(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalChunks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalDataBytes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalFiles(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalNetworkBytes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalPhases(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUnchangedDataBytes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpToDateFilesSkipped(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpdatedFilesReplicated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserConflictFilesSkipped(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWarnings(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var reportSubreportTypeActionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["resync_prep","allow_write","allow_write_revert","test","run"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		reportSubreportTypeActionPropEnum = append(reportSubreportTypeActionPropEnum, v)
	}
}

const (

	// ReportSubreportActionResyncPrep captures enum value "resync_prep"
	ReportSubreportActionResyncPrep string = "resync_prep"

	// ReportSubreportActionAllowWrite captures enum value "allow_write"
	ReportSubreportActionAllowWrite string = "allow_write"

	// ReportSubreportActionAllowWriteRevert captures enum value "allow_write_revert"
	ReportSubreportActionAllowWriteRevert string = "allow_write_revert"

	// ReportSubreportActionTest captures enum value "test"
	ReportSubreportActionTest string = "test"

	// ReportSubreportActionRun captures enum value "run"
	ReportSubreportActionRun string = "run"
)

// prop value enum
func (m *ReportSubreport) validateActionEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, reportSubreportTypeActionPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *ReportSubreport) validateAction(formats strfmt.Registry) error {

	if err := validate.Required("action", "body", m.Action); err != nil {
		return err
	}

	// value enum
	if err := m.validateActionEnum("action", "body", *m.Action); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateAdsStreamsReplicated(formats strfmt.Registry) error {

	if err := validate.Required("ads_streams_replicated", "body", m.AdsStreamsReplicated); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateBlockSpecsReplicated(formats strfmt.Registry) error {

	if err := validate.Required("block_specs_replicated", "body", m.BlockSpecsReplicated); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateBytesRecoverable(formats strfmt.Registry) error {

	if err := validate.Required("bytes_recoverable", "body", m.BytesRecoverable); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateBytesTransferred(formats strfmt.Registry) error {

	if err := validate.Required("bytes_transferred", "body", m.BytesTransferred); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateCharSpecsReplicated(formats strfmt.Registry) error {

	if err := validate.Required("char_specs_replicated", "body", m.CharSpecsReplicated); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateCorrectedLins(formats strfmt.Registry) error {

	if err := validate.Required("corrected_lins", "body", m.CorrectedLins); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateDeadNode(formats strfmt.Registry) error {

	if err := validate.Required("dead_node", "body", m.DeadNode); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateDirectoriesReplicated(formats strfmt.Registry) error {

	if err := validate.Required("directories_replicated", "body", m.DirectoriesReplicated); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateDirsChanged(formats strfmt.Registry) error {

	if err := validate.Required("dirs_changed", "body", m.DirsChanged); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateDirsDeleted(formats strfmt.Registry) error {

	if err := validate.Required("dirs_deleted", "body", m.DirsDeleted); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateDirsMoved(formats strfmt.Registry) error {

	if err := validate.Required("dirs_moved", "body", m.DirsMoved); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateDirsNew(formats strfmt.Registry) error {

	if err := validate.Required("dirs_new", "body", m.DirsNew); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateError(formats strfmt.Registry) error {

	if err := validate.Required("error", "body", m.Error); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateErrorChecksumFilesSkipped(formats strfmt.Registry) error {

	if err := validate.Required("error_checksum_files_skipped", "body", m.ErrorChecksumFilesSkipped); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateErrorIoFilesSkipped(formats strfmt.Registry) error {

	if err := validate.Required("error_io_files_skipped", "body", m.ErrorIoFilesSkipped); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateErrorNetFilesSkipped(formats strfmt.Registry) error {

	if err := validate.Required("error_net_files_skipped", "body", m.ErrorNetFilesSkipped); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateErrors(formats strfmt.Registry) error {

	if err := validate.Required("errors", "body", m.Errors); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateFailedChunks(formats strfmt.Registry) error {

	if err := validate.Required("failed_chunks", "body", m.FailedChunks); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateFifosReplicated(formats strfmt.Registry) error {

	if err := validate.Required("fifos_replicated", "body", m.FifosReplicated); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateFileDataBytes(formats strfmt.Registry) error {

	if err := validate.Required("file_data_bytes", "body", m.FileDataBytes); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateFilesChanged(formats strfmt.Registry) error {

	if err := validate.Required("files_changed", "body", m.FilesChanged); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateFilesLinked(formats strfmt.Registry) error {

	if err := validate.Required("files_linked", "body", m.FilesLinked); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateFilesNew(formats strfmt.Registry) error {

	if err := validate.Required("files_new", "body", m.FilesNew); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateFilesSelected(formats strfmt.Registry) error {

	if err := validate.Required("files_selected", "body", m.FilesSelected); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateFilesTransferred(formats strfmt.Registry) error {

	if err := validate.Required("files_transferred", "body", m.FilesTransferred); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateFilesUnlinked(formats strfmt.Registry) error {

	if err := validate.Required("files_unlinked", "body", m.FilesUnlinked); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateFilesWithAdsReplicated(formats strfmt.Registry) error {

	if err := validate.Required("files_with_ads_replicated", "body", m.FilesWithAdsReplicated); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateFlippedLins(formats strfmt.Registry) error {

	if err := validate.Required("flipped_lins", "body", m.FlippedLins); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateHardLinksReplicated(formats strfmt.Registry) error {

	if err := validate.Required("hard_links_replicated", "body", m.HardLinksReplicated); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateHashExceptionsFixed(formats strfmt.Registry) error {

	if err := validate.Required("hash_exceptions_fixed", "body", m.HashExceptionsFixed); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateHashExceptionsFound(formats strfmt.Registry) error {

	if err := validate.Required("hash_exceptions_found", "body", m.HashExceptionsFound); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateLinsTotal(formats strfmt.Registry) error {

	if err := validate.Required("lins_total", "body", m.LinsTotal); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateNetworkBytesToSource(formats strfmt.Registry) error {

	if err := validate.Required("network_bytes_to_source", "body", m.NetworkBytesToSource); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateNetworkBytesToTarget(formats strfmt.Registry) error {

	if err := validate.Required("network_bytes_to_target", "body", m.NetworkBytesToTarget); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateNewFilesReplicated(formats strfmt.Registry) error {

	if err := validate.Required("new_files_replicated", "body", m.NewFilesReplicated); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateNumRetransmittedFiles(formats strfmt.Registry) error {

	if err := validate.Required("num_retransmitted_files", "body", m.NumRetransmittedFiles); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validatePhases(formats strfmt.Registry) error {

	if err := validate.Required("phases", "body", m.Phases); err != nil {
		return err
	}

	for i := 0; i < len(m.Phases); i++ {
		if swag.IsZero(m.Phases[i]) { // not required
			continue
		}

		if m.Phases[i] != nil {
			if err := m.Phases[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("phases" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *ReportSubreport) validatePolicy(formats strfmt.Registry) error {

	if err := validate.Required("policy", "body", m.Policy); err != nil {
		return err
	}

	if m.Policy != nil {
		if err := m.Policy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("policy")
			}
			return err
		}
	}

	return nil
}

var reportSubreportTypePolicyActionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["copy","sync"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		reportSubreportTypePolicyActionPropEnum = append(reportSubreportTypePolicyActionPropEnum, v)
	}
}

const (

	// ReportSubreportPolicyActionCopy captures enum value "copy"
	ReportSubreportPolicyActionCopy string = "copy"

	// ReportSubreportPolicyActionSync captures enum value "sync"
	ReportSubreportPolicyActionSync string = "sync"
)

// prop value enum
func (m *ReportSubreport) validatePolicyActionEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, reportSubreportTypePolicyActionPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *ReportSubreport) validatePolicyAction(formats strfmt.Registry) error {

	if err := validate.Required("policy_action", "body", m.PolicyAction); err != nil {
		return err
	}

	// value enum
	if err := m.validatePolicyActionEnum("policy_action", "body", *m.PolicyAction); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validatePolicyID(formats strfmt.Registry) error {

	if err := validate.Required("policy_id", "body", m.PolicyID); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validatePolicyName(formats strfmt.Registry) error {

	if err := validate.Required("policy_name", "body", m.PolicyName); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateRegularFilesReplicated(formats strfmt.Registry) error {

	if err := validate.Required("regular_files_replicated", "body", m.RegularFilesReplicated); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateResyncedLins(formats strfmt.Registry) error {

	if err := validate.Required("resynced_lins", "body", m.ResyncedLins); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateRetransmittedFiles(formats strfmt.Registry) error {

	if err := validate.Required("retransmitted_files", "body", m.RetransmittedFiles); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateRetry(formats strfmt.Registry) error {

	if err := validate.Required("retry", "body", m.Retry); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateRunningChunks(formats strfmt.Registry) error {

	if err := validate.Required("running_chunks", "body", m.RunningChunks); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateSocketsReplicated(formats strfmt.Registry) error {

	if err := validate.Required("sockets_replicated", "body", m.SocketsReplicated); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateSourceBytesRecovered(formats strfmt.Registry) error {

	if err := validate.Required("source_bytes_recovered", "body", m.SourceBytesRecovered); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateSourceDirectoriesCreated(formats strfmt.Registry) error {

	if err := validate.Required("source_directories_created", "body", m.SourceDirectoriesCreated); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateSourceDirectoriesDeleted(formats strfmt.Registry) error {

	if err := validate.Required("source_directories_deleted", "body", m.SourceDirectoriesDeleted); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateSourceDirectoriesLinked(formats strfmt.Registry) error {

	if err := validate.Required("source_directories_linked", "body", m.SourceDirectoriesLinked); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateSourceDirectoriesUnlinked(formats strfmt.Registry) error {

	if err := validate.Required("source_directories_unlinked", "body", m.SourceDirectoriesUnlinked); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateSourceDirectoriesVisited(formats strfmt.Registry) error {

	if err := validate.Required("source_directories_visited", "body", m.SourceDirectoriesVisited); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateSourceFilesDeleted(formats strfmt.Registry) error {

	if err := validate.Required("source_files_deleted", "body", m.SourceFilesDeleted); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateSourceFilesLinked(formats strfmt.Registry) error {

	if err := validate.Required("source_files_linked", "body", m.SourceFilesLinked); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateSourceFilesUnlinked(formats strfmt.Registry) error {

	if err := validate.Required("source_files_unlinked", "body", m.SourceFilesUnlinked); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateSparseDataBytes(formats strfmt.Registry) error {

	if err := validate.Required("sparse_data_bytes", "body", m.SparseDataBytes); err != nil {
		return err
	}

	return nil
}

var reportSubreportTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["scheduled","running","paused","finished","failed","canceled","needs_attention","skipped","pending","unknown"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		reportSubreportTypeStatePropEnum = append(reportSubreportTypeStatePropEnum, v)
	}
}

const (

	// ReportSubreportStateScheduled captures enum value "scheduled"
	ReportSubreportStateScheduled string = "scheduled"

	// ReportSubreportStateRunning captures enum value "running"
	ReportSubreportStateRunning string = "running"

	// ReportSubreportStatePaused captures enum value "paused"
	ReportSubreportStatePaused string = "paused"

	// ReportSubreportStateFinished captures enum value "finished"
	ReportSubreportStateFinished string = "finished"

	// ReportSubreportStateFailed captures enum value "failed"
	ReportSubreportStateFailed string = "failed"

	// ReportSubreportStateCanceled captures enum value "canceled"
	ReportSubreportStateCanceled string = "canceled"

	// ReportSubreportStateNeedsAttention captures enum value "needs_attention"
	ReportSubreportStateNeedsAttention string = "needs_attention"

	// ReportSubreportStateSkipped captures enum value "skipped"
	ReportSubreportStateSkipped string = "skipped"

	// ReportSubreportStatePending captures enum value "pending"
	ReportSubreportStatePending string = "pending"

	// ReportSubreportStateUnknown captures enum value "unknown"
	ReportSubreportStateUnknown string = "unknown"
)

// prop value enum
func (m *ReportSubreport) validateStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, reportSubreportTypeStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *ReportSubreport) validateState(formats strfmt.Registry) error {

	if err := validate.Required("state", "body", m.State); err != nil {
		return err
	}

	// value enum
	if err := m.validateStateEnum("state", "body", *m.State); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateSucceededChunks(formats strfmt.Registry) error {

	if err := validate.Required("succeeded_chunks", "body", m.SucceededChunks); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateSymlinksReplicated(formats strfmt.Registry) error {

	if err := validate.Required("symlinks_replicated", "body", m.SymlinksReplicated); err != nil {
		return err
	}

	return nil
}

var reportSubreportTypeSyncTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["invalid","legacy","initial","incremental","upgrade","fofb","domainmark"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		reportSubreportTypeSyncTypePropEnum = append(reportSubreportTypeSyncTypePropEnum, v)
	}
}

const (

	// ReportSubreportSyncTypeInvalid captures enum value "invalid"
	ReportSubreportSyncTypeInvalid string = "invalid"

	// ReportSubreportSyncTypeLegacy captures enum value "legacy"
	ReportSubreportSyncTypeLegacy string = "legacy"

	// ReportSubreportSyncTypeInitial captures enum value "initial"
	ReportSubreportSyncTypeInitial string = "initial"

	// ReportSubreportSyncTypeIncremental captures enum value "incremental"
	ReportSubreportSyncTypeIncremental string = "incremental"

	// ReportSubreportSyncTypeUpgrade captures enum value "upgrade"
	ReportSubreportSyncTypeUpgrade string = "upgrade"

	// ReportSubreportSyncTypeFofb captures enum value "fofb"
	ReportSubreportSyncTypeFofb string = "fofb"

	// ReportSubreportSyncTypeDomainmark captures enum value "domainmark"
	ReportSubreportSyncTypeDomainmark string = "domainmark"
)

// prop value enum
func (m *ReportSubreport) validateSyncTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, reportSubreportTypeSyncTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *ReportSubreport) validateSyncType(formats strfmt.Registry) error {

	if err := validate.Required("sync_type", "body", m.SyncType); err != nil {
		return err
	}

	// value enum
	if err := m.validateSyncTypeEnum("sync_type", "body", *m.SyncType); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateTargetBytesRecovered(formats strfmt.Registry) error {

	if err := validate.Required("target_bytes_recovered", "body", m.TargetBytesRecovered); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateTargetDirectoriesCreated(formats strfmt.Registry) error {

	if err := validate.Required("target_directories_created", "body", m.TargetDirectoriesCreated); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateTargetDirectoriesDeleted(formats strfmt.Registry) error {

	if err := validate.Required("target_directories_deleted", "body", m.TargetDirectoriesDeleted); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateTargetDirectoriesLinked(formats strfmt.Registry) error {

	if err := validate.Required("target_directories_linked", "body", m.TargetDirectoriesLinked); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateTargetDirectoriesUnlinked(formats strfmt.Registry) error {

	if err := validate.Required("target_directories_unlinked", "body", m.TargetDirectoriesUnlinked); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateTargetFilesDeleted(formats strfmt.Registry) error {

	if err := validate.Required("target_files_deleted", "body", m.TargetFilesDeleted); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateTargetFilesLinked(formats strfmt.Registry) error {

	if err := validate.Required("target_files_linked", "body", m.TargetFilesLinked); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateTargetFilesUnlinked(formats strfmt.Registry) error {

	if err := validate.Required("target_files_unlinked", "body", m.TargetFilesUnlinked); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateTargetSnapshots(formats strfmt.Registry) error {

	if err := validate.Required("target_snapshots", "body", m.TargetSnapshots); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateTotalChunks(formats strfmt.Registry) error {

	if err := validate.Required("total_chunks", "body", m.TotalChunks); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateTotalDataBytes(formats strfmt.Registry) error {

	if err := validate.Required("total_data_bytes", "body", m.TotalDataBytes); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateTotalFiles(formats strfmt.Registry) error {

	if err := validate.Required("total_files", "body", m.TotalFiles); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateTotalNetworkBytes(formats strfmt.Registry) error {

	if err := validate.Required("total_network_bytes", "body", m.TotalNetworkBytes); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateTotalPhases(formats strfmt.Registry) error {

	if err := validate.Required("total_phases", "body", m.TotalPhases); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateUnchangedDataBytes(formats strfmt.Registry) error {

	if err := validate.Required("unchanged_data_bytes", "body", m.UnchangedDataBytes); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateUpToDateFilesSkipped(formats strfmt.Registry) error {

	if err := validate.Required("up_to_date_files_skipped", "body", m.UpToDateFilesSkipped); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateUpdatedFilesReplicated(formats strfmt.Registry) error {

	if err := validate.Required("updated_files_replicated", "body", m.UpdatedFilesReplicated); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateUserConflictFilesSkipped(formats strfmt.Registry) error {

	if err := validate.Required("user_conflict_files_skipped", "body", m.UserConflictFilesSkipped); err != nil {
		return err
	}

	return nil
}

func (m *ReportSubreport) validateWarnings(formats strfmt.Registry) error {

	if err := validate.Required("warnings", "body", m.Warnings); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ReportSubreport) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ReportSubreport) UnmarshalBinary(b []byte) error {
	var res ReportSubreport
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
