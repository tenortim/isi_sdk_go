// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// ClusterEmailExtended Cluster email notification settings.
// swagger:model ClusterEmailExtended
type ClusterEmailExtended struct {

	// This setting determines how notifications will be batched together to be sent by email.  'none' means each notification will be sent separately.  'severity' means notifications of the same severity will be sent together.  'category' means notifications of the same category will be sent together.  'all' means all notifications will be batched together and sent in a single email.
	// Enum: [all severity category none]
	BatchMode string `json:"batch_mode,omitempty"`

	// The address of the SMTP server to be used for relaying the notification messages.  An SMTP server is required in order to send notifications.  If this string is empty, no emails will be sent.
	MailRelay string `json:"mail_relay,omitempty"`

	// The full email address that will appear as the sender of notification messages.
	MailSender string `json:"mail_sender,omitempty"`

	// The subject line for notification messages from this cluster.
	MailSubject string `json:"mail_subject,omitempty"`

	// Password to authenticate with if SMTP authentication is being used.
	SMTPAuthPasswd string `json:"smtp_auth_passwd,omitempty"`

	// The type of secure communication protocol to use if SMTP is being used.  If 'none', plain text will be used, if 'starttls', the encrypted STARTTLS protocol will be used.
	// Enum: [none starttls]
	SMTPAuthSecurity string `json:"smtp_auth_security,omitempty"`

	// Username to authenticate with if SMTP authentication is being used.
	SMTPAuthUsername string `json:"smtp_auth_username,omitempty"`

	// The port on the SMTP server to be used for relaying the notification messages.
	SMTPPort int64 `json:"smtp_port,omitempty"`

	// If true, this cluster will send SMTP authentication credentials to the SMTP relay server in order to send its notification emails.  If false, the cluster will attempt to send its notification emails without authentication.
	UseSMTPAuth bool `json:"use_smtp_auth,omitempty"`

	// Location of a custom template file that can be used to specify the layout of the notification emails.
	UserTemplate string `json:"user_template,omitempty"`
}

// Validate validates this cluster email extended
func (m *ClusterEmailExtended) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBatchMode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSMTPAuthSecurity(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var clusterEmailExtendedTypeBatchModePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["all","severity","category","none"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterEmailExtendedTypeBatchModePropEnum = append(clusterEmailExtendedTypeBatchModePropEnum, v)
	}
}

const (

	// ClusterEmailExtendedBatchModeAll captures enum value "all"
	ClusterEmailExtendedBatchModeAll string = "all"

	// ClusterEmailExtendedBatchModeSeverity captures enum value "severity"
	ClusterEmailExtendedBatchModeSeverity string = "severity"

	// ClusterEmailExtendedBatchModeCategory captures enum value "category"
	ClusterEmailExtendedBatchModeCategory string = "category"

	// ClusterEmailExtendedBatchModeNone captures enum value "none"
	ClusterEmailExtendedBatchModeNone string = "none"
)

// prop value enum
func (m *ClusterEmailExtended) validateBatchModeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, clusterEmailExtendedTypeBatchModePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *ClusterEmailExtended) validateBatchMode(formats strfmt.Registry) error {

	if swag.IsZero(m.BatchMode) { // not required
		return nil
	}

	// value enum
	if err := m.validateBatchModeEnum("batch_mode", "body", m.BatchMode); err != nil {
		return err
	}

	return nil
}

var clusterEmailExtendedTypeSMTPAuthSecurityPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["none","starttls"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		clusterEmailExtendedTypeSMTPAuthSecurityPropEnum = append(clusterEmailExtendedTypeSMTPAuthSecurityPropEnum, v)
	}
}

const (

	// ClusterEmailExtendedSMTPAuthSecurityNone captures enum value "none"
	ClusterEmailExtendedSMTPAuthSecurityNone string = "none"

	// ClusterEmailExtendedSMTPAuthSecurityStarttls captures enum value "starttls"
	ClusterEmailExtendedSMTPAuthSecurityStarttls string = "starttls"
)

// prop value enum
func (m *ClusterEmailExtended) validateSMTPAuthSecurityEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, clusterEmailExtendedTypeSMTPAuthSecurityPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *ClusterEmailExtended) validateSMTPAuthSecurity(formats strfmt.Registry) error {

	if swag.IsZero(m.SMTPAuthSecurity) { // not required
		return nil
	}

	// value enum
	if err := m.validateSMTPAuthSecurityEnum("smtp_auth_security", "body", m.SMTPAuthSecurity); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *ClusterEmailExtended) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ClusterEmailExtended) UnmarshalBinary(b []byte) error {
	var res ClusterEmailExtended
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
