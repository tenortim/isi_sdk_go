// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// SyncSettingsSettings sync settings settings
// swagger:model SyncSettingsSettings
type SyncSettingsSettings struct {

	// The per-worker burst socket memory constraint, in bytes.
	BurstMemoryConstraint int64 `json:"burst_memory_constraint,omitempty"`

	// The per-worker burst socket buffer coalesced data, in bytes.
	BurstSocketBufferSize int64 `json:"burst_socket_buffer_size,omitempty"`

	// NOTE: This field should not be changed without the help of Isilon support.  Default for the "force_interface" property that will be applied to each new sync policy unless otherwise specified at the time of policy creation.  Determines whether data is sent only through the subnet and pool specified in the "source_network" field. This option can be useful if there are multiple interfaces for the given source subnet.
	ForceInterface bool `json:"force_interface,omitempty"`

	// The max concurrent jobs that SyncIQ can support. This number is based on the size of the current cluster and the current SyncIQ worker throttle rule.
	MaxConcurrentJobs int64 `json:"max_concurrent_jobs,omitempty"`

	// Email sync reports to these addresses.
	ReportEmail []string `json:"report_email"`

	// The default length of time (in seconds) a policy report will be stored.
	ReportMaxAge int64 `json:"report_max_age,omitempty"`

	// The default maximum number of reports to retain for a policy.
	// Maximum: 2000
	// Minimum: 1
	ReportMaxCount int64 `json:"report_max_count,omitempty"`

	// Default for the "restrict_target_network" property that will be applied to each new sync policy unless otherwise specified at the time of policy creation.  If you specify true, and you specify a SmartConnect zone in the "target_host" field, replication policies will connect only to nodes in the specified SmartConnect zone.  If you specify false, replication policies are not restricted to specific nodes on the target cluster.
	RestrictTargetNetwork bool `json:"restrict_target_network,omitempty"`

	// If disabled, no RPO alerts will be generated.
	RpoAlerts bool `json:"rpo_alerts,omitempty"`

	// Specifies if the SyncIQ service currently on, paused, or off.  If paused, all sync jobs will be paused.  If turned off, all jobs will be canceled.
	// Enum: [on off paused]
	Service string `json:"service,omitempty"`

	// Restricts replication policies on the local cluster to running on the specified subnet and pool.
	SourceNetwork *SyncPolicySourceNetwork `json:"source_network,omitempty"`

	// The interval (in seconds) in which treewalk syncs are forced to checkpoint.
	// Minimum: 0
	TwChkptInterval *int64 `json:"tw_chkpt_interval,omitempty"`
}

// Validate validates this sync settings settings
func (m *SyncSettingsSettings) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateReportMaxCount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateService(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourceNetwork(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTwChkptInterval(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SyncSettingsSettings) validateReportMaxCount(formats strfmt.Registry) error {

	if swag.IsZero(m.ReportMaxCount) { // not required
		return nil
	}

	if err := validate.MinimumInt("report_max_count", "body", int64(m.ReportMaxCount), 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("report_max_count", "body", int64(m.ReportMaxCount), 2000, false); err != nil {
		return err
	}

	return nil
}

var syncSettingsSettingsTypeServicePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["on","off","paused"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		syncSettingsSettingsTypeServicePropEnum = append(syncSettingsSettingsTypeServicePropEnum, v)
	}
}

const (

	// SyncSettingsSettingsServiceOn captures enum value "on"
	SyncSettingsSettingsServiceOn string = "on"

	// SyncSettingsSettingsServiceOff captures enum value "off"
	SyncSettingsSettingsServiceOff string = "off"

	// SyncSettingsSettingsServicePaused captures enum value "paused"
	SyncSettingsSettingsServicePaused string = "paused"
)

// prop value enum
func (m *SyncSettingsSettings) validateServiceEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, syncSettingsSettingsTypeServicePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *SyncSettingsSettings) validateService(formats strfmt.Registry) error {

	if swag.IsZero(m.Service) { // not required
		return nil
	}

	// value enum
	if err := m.validateServiceEnum("service", "body", m.Service); err != nil {
		return err
	}

	return nil
}

func (m *SyncSettingsSettings) validateSourceNetwork(formats strfmt.Registry) error {

	if swag.IsZero(m.SourceNetwork) { // not required
		return nil
	}

	if m.SourceNetwork != nil {
		if err := m.SourceNetwork.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("source_network")
			}
			return err
		}
	}

	return nil
}

func (m *SyncSettingsSettings) validateTwChkptInterval(formats strfmt.Registry) error {

	if swag.IsZero(m.TwChkptInterval) { // not required
		return nil
	}

	if err := validate.MinimumInt("tw_chkpt_interval", "body", int64(*m.TwChkptInterval), 0, false); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SyncSettingsSettings) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SyncSettingsSettings) UnmarshalBinary(b []byte) error {
	var res SyncSettingsSettings
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
