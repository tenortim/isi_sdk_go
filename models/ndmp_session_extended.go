// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// NdmpSessionExtended ndmp session extended
// swagger:model NdmpSessionExtended
type NdmpSessionExtended struct {

	// Bytes transferred to/from the filesystem
	// Required: true
	DataBytesTransferred *int64 `json:"data_bytes_transferred"`

	// State of the NDMP Data Service
	// Required: true
	// Enum: [IDLE LISTEN ACTIVE CONNECTED HALTED INVALID]
	DataState *string `json:"data_state"`

	// The path being recovered to
	// Required: true
	DestPath *string `json:"dest_path"`

	// IP address of the DMA
	// Required: true
	DmaIPAddr *string `json:"dma_ip_addr"`

	// Number of seconds elapsed since the backup was started
	// Required: true
	ElapsedTime *int64 `json:"elapsed_time"`

	// Unique display ID.
	// Required: true
	ID *string `json:"id"`

	// Bytes transferred to/from tape or remote writer
	// Required: true
	MoverBytesTransferred *int64 `json:"mover_bytes_transferred"`

	// State of the NDMP Mover Service
	// Required: true
	// Enum: [IDLE LISTEN ACTIVE PAUSED HALTED INVALID]
	MoverState *string `json:"mover_state"`

	// The type of backup session
	// Required: true
	// Enum: [None Backup Recover Recover file history]
	Operation *string `json:"operation"`

	// IP address of the remote NDMP participant
	// Required: true
	RemoteIPAddr *string `json:"remote_ip_addr"`

	// Name of the media changer device used if any
	// Required: true
	ScsiDevice *string `json:"scsi_device"`

	// Session ID in form <lnn>.<pid>.
	// Required: true
	Session *string `json:"session"`

	// The path being backed up
	// Required: true
	SourcePath *string `json:"source_path"`

	// Time backup was started in seconds since epoch
	// Required: true
	StartTime *int64 `json:"start_time"`

	// Name of the tape device used if any
	// Required: true
	TapeDevice *string `json:"tape_device"`

	// Describes the mode in which the tape is opened
	// Required: true
	// Enum: [Read Read/Write Raw Invalid]
	TapeOpenMode *string `json:"tape_open_mode"`

	// The throughput in MB/s
	// Required: true
	Throughput *int64 `json:"throughput"`
}

// Validate validates this ndmp session extended
func (m *NdmpSessionExtended) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDataBytesTransferred(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDataState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDestPath(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDmaIPAddr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateElapsedTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMoverBytesTransferred(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMoverState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOperation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRemoteIPAddr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScsiDevice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSession(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourcePath(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStartTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTapeDevice(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTapeOpenMode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateThroughput(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NdmpSessionExtended) validateDataBytesTransferred(formats strfmt.Registry) error {

	if err := validate.Required("data_bytes_transferred", "body", m.DataBytesTransferred); err != nil {
		return err
	}

	return nil
}

var ndmpSessionExtendedTypeDataStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["IDLE","LISTEN","ACTIVE","CONNECTED","HALTED","INVALID"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		ndmpSessionExtendedTypeDataStatePropEnum = append(ndmpSessionExtendedTypeDataStatePropEnum, v)
	}
}

const (

	// NdmpSessionExtendedDataStateIDLE captures enum value "IDLE"
	NdmpSessionExtendedDataStateIDLE string = "IDLE"

	// NdmpSessionExtendedDataStateLISTEN captures enum value "LISTEN"
	NdmpSessionExtendedDataStateLISTEN string = "LISTEN"

	// NdmpSessionExtendedDataStateACTIVE captures enum value "ACTIVE"
	NdmpSessionExtendedDataStateACTIVE string = "ACTIVE"

	// NdmpSessionExtendedDataStateCONNECTED captures enum value "CONNECTED"
	NdmpSessionExtendedDataStateCONNECTED string = "CONNECTED"

	// NdmpSessionExtendedDataStateHALTED captures enum value "HALTED"
	NdmpSessionExtendedDataStateHALTED string = "HALTED"

	// NdmpSessionExtendedDataStateINVALID captures enum value "INVALID"
	NdmpSessionExtendedDataStateINVALID string = "INVALID"
)

// prop value enum
func (m *NdmpSessionExtended) validateDataStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, ndmpSessionExtendedTypeDataStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *NdmpSessionExtended) validateDataState(formats strfmt.Registry) error {

	if err := validate.Required("data_state", "body", m.DataState); err != nil {
		return err
	}

	// value enum
	if err := m.validateDataStateEnum("data_state", "body", *m.DataState); err != nil {
		return err
	}

	return nil
}

func (m *NdmpSessionExtended) validateDestPath(formats strfmt.Registry) error {

	if err := validate.Required("dest_path", "body", m.DestPath); err != nil {
		return err
	}

	return nil
}

func (m *NdmpSessionExtended) validateDmaIPAddr(formats strfmt.Registry) error {

	if err := validate.Required("dma_ip_addr", "body", m.DmaIPAddr); err != nil {
		return err
	}

	return nil
}

func (m *NdmpSessionExtended) validateElapsedTime(formats strfmt.Registry) error {

	if err := validate.Required("elapsed_time", "body", m.ElapsedTime); err != nil {
		return err
	}

	return nil
}

func (m *NdmpSessionExtended) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

func (m *NdmpSessionExtended) validateMoverBytesTransferred(formats strfmt.Registry) error {

	if err := validate.Required("mover_bytes_transferred", "body", m.MoverBytesTransferred); err != nil {
		return err
	}

	return nil
}

var ndmpSessionExtendedTypeMoverStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["IDLE","LISTEN","ACTIVE","PAUSED","HALTED","INVALID"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		ndmpSessionExtendedTypeMoverStatePropEnum = append(ndmpSessionExtendedTypeMoverStatePropEnum, v)
	}
}

const (

	// NdmpSessionExtendedMoverStateIDLE captures enum value "IDLE"
	NdmpSessionExtendedMoverStateIDLE string = "IDLE"

	// NdmpSessionExtendedMoverStateLISTEN captures enum value "LISTEN"
	NdmpSessionExtendedMoverStateLISTEN string = "LISTEN"

	// NdmpSessionExtendedMoverStateACTIVE captures enum value "ACTIVE"
	NdmpSessionExtendedMoverStateACTIVE string = "ACTIVE"

	// NdmpSessionExtendedMoverStatePAUSED captures enum value "PAUSED"
	NdmpSessionExtendedMoverStatePAUSED string = "PAUSED"

	// NdmpSessionExtendedMoverStateHALTED captures enum value "HALTED"
	NdmpSessionExtendedMoverStateHALTED string = "HALTED"

	// NdmpSessionExtendedMoverStateINVALID captures enum value "INVALID"
	NdmpSessionExtendedMoverStateINVALID string = "INVALID"
)

// prop value enum
func (m *NdmpSessionExtended) validateMoverStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, ndmpSessionExtendedTypeMoverStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *NdmpSessionExtended) validateMoverState(formats strfmt.Registry) error {

	if err := validate.Required("mover_state", "body", m.MoverState); err != nil {
		return err
	}

	// value enum
	if err := m.validateMoverStateEnum("mover_state", "body", *m.MoverState); err != nil {
		return err
	}

	return nil
}

var ndmpSessionExtendedTypeOperationPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["None","Backup","Recover","Recover file history"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		ndmpSessionExtendedTypeOperationPropEnum = append(ndmpSessionExtendedTypeOperationPropEnum, v)
	}
}

const (

	// NdmpSessionExtendedOperationNone captures enum value "None"
	NdmpSessionExtendedOperationNone string = "None"

	// NdmpSessionExtendedOperationBackup captures enum value "Backup"
	NdmpSessionExtendedOperationBackup string = "Backup"

	// NdmpSessionExtendedOperationRecover captures enum value "Recover"
	NdmpSessionExtendedOperationRecover string = "Recover"

	// NdmpSessionExtendedOperationRecoverFileHistory captures enum value "Recover file history"
	NdmpSessionExtendedOperationRecoverFileHistory string = "Recover file history"
)

// prop value enum
func (m *NdmpSessionExtended) validateOperationEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, ndmpSessionExtendedTypeOperationPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *NdmpSessionExtended) validateOperation(formats strfmt.Registry) error {

	if err := validate.Required("operation", "body", m.Operation); err != nil {
		return err
	}

	// value enum
	if err := m.validateOperationEnum("operation", "body", *m.Operation); err != nil {
		return err
	}

	return nil
}

func (m *NdmpSessionExtended) validateRemoteIPAddr(formats strfmt.Registry) error {

	if err := validate.Required("remote_ip_addr", "body", m.RemoteIPAddr); err != nil {
		return err
	}

	return nil
}

func (m *NdmpSessionExtended) validateScsiDevice(formats strfmt.Registry) error {

	if err := validate.Required("scsi_device", "body", m.ScsiDevice); err != nil {
		return err
	}

	return nil
}

func (m *NdmpSessionExtended) validateSession(formats strfmt.Registry) error {

	if err := validate.Required("session", "body", m.Session); err != nil {
		return err
	}

	return nil
}

func (m *NdmpSessionExtended) validateSourcePath(formats strfmt.Registry) error {

	if err := validate.Required("source_path", "body", m.SourcePath); err != nil {
		return err
	}

	return nil
}

func (m *NdmpSessionExtended) validateStartTime(formats strfmt.Registry) error {

	if err := validate.Required("start_time", "body", m.StartTime); err != nil {
		return err
	}

	return nil
}

func (m *NdmpSessionExtended) validateTapeDevice(formats strfmt.Registry) error {

	if err := validate.Required("tape_device", "body", m.TapeDevice); err != nil {
		return err
	}

	return nil
}

var ndmpSessionExtendedTypeTapeOpenModePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Read","Read/Write","Raw","Invalid"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		ndmpSessionExtendedTypeTapeOpenModePropEnum = append(ndmpSessionExtendedTypeTapeOpenModePropEnum, v)
	}
}

const (

	// NdmpSessionExtendedTapeOpenModeRead captures enum value "Read"
	NdmpSessionExtendedTapeOpenModeRead string = "Read"

	// NdmpSessionExtendedTapeOpenModeReadWrite captures enum value "Read/Write"
	NdmpSessionExtendedTapeOpenModeReadWrite string = "Read/Write"

	// NdmpSessionExtendedTapeOpenModeRaw captures enum value "Raw"
	NdmpSessionExtendedTapeOpenModeRaw string = "Raw"

	// NdmpSessionExtendedTapeOpenModeInvalid captures enum value "Invalid"
	NdmpSessionExtendedTapeOpenModeInvalid string = "Invalid"
)

// prop value enum
func (m *NdmpSessionExtended) validateTapeOpenModeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, ndmpSessionExtendedTypeTapeOpenModePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *NdmpSessionExtended) validateTapeOpenMode(formats strfmt.Registry) error {

	if err := validate.Required("tape_open_mode", "body", m.TapeOpenMode); err != nil {
		return err
	}

	// value enum
	if err := m.validateTapeOpenModeEnum("tape_open_mode", "body", *m.TapeOpenMode); err != nil {
		return err
	}

	return nil
}

func (m *NdmpSessionExtended) validateThroughput(formats strfmt.Registry) error {

	if err := validate.Required("throughput", "body", m.Throughput); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NdmpSessionExtended) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NdmpSessionExtended) UnmarshalBinary(b []byte) error {
	var res NdmpSessionExtended
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
