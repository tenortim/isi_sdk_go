// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// StoragepoolStoragepool storagepool storagepool
// swagger:model StoragepoolStoragepool
type StoragepoolStoragepool struct {

	// Indicates if enabling L3 is possible. L3 cannot be enabled if there are unprovisioned drives.
	// Required: true
	CanEnableL3 *bool `json:"can_enable_l3"`

	// The names or IDs of the pool's children.
	Children []string `json:"children"`

	// An array of containing any health issues with this pool.  If the pool is healthy, the list is empty.  Only appears on 'nodepool' type storagepools.
	HealthFlags []string `json:"health_flags"`

	// The system ID given to the pool.
	// Required: true
	ID *int64 `json:"id"`

	// Use SSDs in this node pool for L3 cache.
	// Required: true
	L3 *bool `json:"l3"`

	// 'storage' if the 'l3' option is disabled. If the l3 option is enabled, 'migrating' if any SSDs in this node pool have not yet been migrated to L3. If all SSDs have been migrated, 'l3'.
	// Required: true
	// Enum: [l3 storage migrating]
	L3Status *string `json:"l3_status"`

	// The nodes that are part of this pool.
	// Required: true
	Lnns []int64 `json:"lnns"`

	// Whether or not the node pool is manually managed.
	Manual bool `json:"manual,omitempty"`

	// The pool name.
	// Required: true
	Name *string `json:"name"`

	// The underlying protection policy.
	ProtectionPolicy string `json:"protection_policy,omitempty"`

	// The pool type.
	// Required: true
	// Enum: [tier nodepool]
	Type *string `json:"type"`

	// Total pool usage.
	// Required: true
	Usage *StoragepoolTierUsage `json:"usage"`
}

// Validate validates this storagepool storagepool
func (m *StoragepoolStoragepool) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCanEnableL3(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHealthFlags(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateL3(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateL3Status(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLnns(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUsage(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *StoragepoolStoragepool) validateCanEnableL3(formats strfmt.Registry) error {

	if err := validate.Required("can_enable_l3", "body", m.CanEnableL3); err != nil {
		return err
	}

	return nil
}

var storagepoolStoragepoolHealthFlagsItemsEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["underprovisioned","missing_drives","devices_down","devices_smartfailed","waiting_repair"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		storagepoolStoragepoolHealthFlagsItemsEnum = append(storagepoolStoragepoolHealthFlagsItemsEnum, v)
	}
}

func (m *StoragepoolStoragepool) validateHealthFlagsItemsEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, storagepoolStoragepoolHealthFlagsItemsEnum); err != nil {
		return err
	}
	return nil
}

func (m *StoragepoolStoragepool) validateHealthFlags(formats strfmt.Registry) error {

	if swag.IsZero(m.HealthFlags) { // not required
		return nil
	}

	for i := 0; i < len(m.HealthFlags); i++ {

		// value enum
		if err := m.validateHealthFlagsItemsEnum("health_flags"+"."+strconv.Itoa(i), "body", m.HealthFlags[i]); err != nil {
			return err
		}

	}

	return nil
}

func (m *StoragepoolStoragepool) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

func (m *StoragepoolStoragepool) validateL3(formats strfmt.Registry) error {

	if err := validate.Required("l3", "body", m.L3); err != nil {
		return err
	}

	return nil
}

var storagepoolStoragepoolTypeL3StatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["l3","storage","migrating"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		storagepoolStoragepoolTypeL3StatusPropEnum = append(storagepoolStoragepoolTypeL3StatusPropEnum, v)
	}
}

const (

	// StoragepoolStoragepoolL3StatusL3 captures enum value "l3"
	StoragepoolStoragepoolL3StatusL3 string = "l3"

	// StoragepoolStoragepoolL3StatusStorage captures enum value "storage"
	StoragepoolStoragepoolL3StatusStorage string = "storage"

	// StoragepoolStoragepoolL3StatusMigrating captures enum value "migrating"
	StoragepoolStoragepoolL3StatusMigrating string = "migrating"
)

// prop value enum
func (m *StoragepoolStoragepool) validateL3StatusEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, storagepoolStoragepoolTypeL3StatusPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *StoragepoolStoragepool) validateL3Status(formats strfmt.Registry) error {

	if err := validate.Required("l3_status", "body", m.L3Status); err != nil {
		return err
	}

	// value enum
	if err := m.validateL3StatusEnum("l3_status", "body", *m.L3Status); err != nil {
		return err
	}

	return nil
}

func (m *StoragepoolStoragepool) validateLnns(formats strfmt.Registry) error {

	if err := validate.Required("lnns", "body", m.Lnns); err != nil {
		return err
	}

	return nil
}

func (m *StoragepoolStoragepool) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

var storagepoolStoragepoolTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["tier","nodepool"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		storagepoolStoragepoolTypeTypePropEnum = append(storagepoolStoragepoolTypeTypePropEnum, v)
	}
}

const (

	// StoragepoolStoragepoolTypeTier captures enum value "tier"
	StoragepoolStoragepoolTypeTier string = "tier"

	// StoragepoolStoragepoolTypeNodepool captures enum value "nodepool"
	StoragepoolStoragepoolTypeNodepool string = "nodepool"
)

// prop value enum
func (m *StoragepoolStoragepool) validateTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, storagepoolStoragepoolTypeTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *StoragepoolStoragepool) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

func (m *StoragepoolStoragepool) validateUsage(formats strfmt.Registry) error {

	if err := validate.Required("usage", "body", m.Usage); err != nil {
		return err
	}

	if m.Usage != nil {
		if err := m.Usage.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("usage")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *StoragepoolStoragepool) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *StoragepoolStoragepool) UnmarshalBinary(b []byte) error {
	var res StoragepoolStoragepool
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
