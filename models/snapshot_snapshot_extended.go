// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// SnapshotSnapshotExtended snapshot snapshot extended
// swagger:model SnapshotSnapshotExtended
type SnapshotSnapshotExtended struct {
	SnapshotSnapshot

	// The Unix Epoch time the snapshot was created.
	// Required: true
	Created *int64 `json:"created"`

	// True if the snapshot has one or more locks present see, see the locks subresource of a snapshot for a list of locks.
	// Required: true
	HasLocks *bool `json:"has_locks"`

	// The system ID given to the snapshot. This is useful for tracking the status of delete pending snapshots.
	// Required: true
	ID *int64 `json:"id"`

	// The /ifs path snapshotted.
	Path string `json:"path,omitempty"`

	// Percentage of /ifs used for storing this snapshot.
	// Required: true
	PctFilesystem *float64 `json:"pct_filesystem"`

	// Percentage of configured snapshot reserved used for storing this snapshot.
	// Required: true
	PctReserve *float64 `json:"pct_reserve"`

	// The name of the schedule used to create this snapshot, if applicable.
	Schedule string `json:"schedule,omitempty"`

	// The amount of shadow bytes referred to by this snapshot.
	// Required: true
	ShadowBytes *int64 `json:"shadow_bytes"`

	// The amount of storage in bytes used to store this snapshot.
	// Required: true
	Size *int64 `json:"size"`

	// Snapshot state.
	// Required: true
	// Enum: [active deleting]
	State *string `json:"state"`

	// The ID of the snapshot pointed to if this is an alias.
	TargetID int64 `json:"target_id,omitempty"`

	// The name of the snapshot pointed to if this is an alias.
	TargetName string `json:"target_name,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *SnapshotSnapshotExtended) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 SnapshotSnapshot
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	m.SnapshotSnapshot = aO0

	// AO1
	var dataAO1 struct {
		Created *int64 `json:"created"`

		HasLocks *bool `json:"has_locks"`

		ID *int64 `json:"id"`

		Path string `json:"path,omitempty"`

		PctFilesystem *float64 `json:"pct_filesystem"`

		PctReserve *float64 `json:"pct_reserve"`

		Schedule string `json:"schedule,omitempty"`

		ShadowBytes *int64 `json:"shadow_bytes"`

		Size *int64 `json:"size"`

		State *string `json:"state"`

		TargetID int64 `json:"target_id,omitempty"`

		TargetName string `json:"target_name,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.Created = dataAO1.Created

	m.HasLocks = dataAO1.HasLocks

	m.ID = dataAO1.ID

	m.Path = dataAO1.Path

	m.PctFilesystem = dataAO1.PctFilesystem

	m.PctReserve = dataAO1.PctReserve

	m.Schedule = dataAO1.Schedule

	m.ShadowBytes = dataAO1.ShadowBytes

	m.Size = dataAO1.Size

	m.State = dataAO1.State

	m.TargetID = dataAO1.TargetID

	m.TargetName = dataAO1.TargetName

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m SnapshotSnapshotExtended) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	aO0, err := swag.WriteJSON(m.SnapshotSnapshot)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)

	var dataAO1 struct {
		Created *int64 `json:"created"`

		HasLocks *bool `json:"has_locks"`

		ID *int64 `json:"id"`

		Path string `json:"path,omitempty"`

		PctFilesystem *float64 `json:"pct_filesystem"`

		PctReserve *float64 `json:"pct_reserve"`

		Schedule string `json:"schedule,omitempty"`

		ShadowBytes *int64 `json:"shadow_bytes"`

		Size *int64 `json:"size"`

		State *string `json:"state"`

		TargetID int64 `json:"target_id,omitempty"`

		TargetName string `json:"target_name,omitempty"`
	}

	dataAO1.Created = m.Created

	dataAO1.HasLocks = m.HasLocks

	dataAO1.ID = m.ID

	dataAO1.Path = m.Path

	dataAO1.PctFilesystem = m.PctFilesystem

	dataAO1.PctReserve = m.PctReserve

	dataAO1.Schedule = m.Schedule

	dataAO1.ShadowBytes = m.ShadowBytes

	dataAO1.Size = m.Size

	dataAO1.State = m.State

	dataAO1.TargetID = m.TargetID

	dataAO1.TargetName = m.TargetName

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this snapshot snapshot extended
func (m *SnapshotSnapshotExtended) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with SnapshotSnapshot
	if err := m.SnapshotSnapshot.Validate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHasLocks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePctFilesystem(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePctReserve(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateShadowBytes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSize(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SnapshotSnapshotExtended) validateCreated(formats strfmt.Registry) error {

	if err := validate.Required("created", "body", m.Created); err != nil {
		return err
	}

	return nil
}

func (m *SnapshotSnapshotExtended) validateHasLocks(formats strfmt.Registry) error {

	if err := validate.Required("has_locks", "body", m.HasLocks); err != nil {
		return err
	}

	return nil
}

func (m *SnapshotSnapshotExtended) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

func (m *SnapshotSnapshotExtended) validatePctFilesystem(formats strfmt.Registry) error {

	if err := validate.Required("pct_filesystem", "body", m.PctFilesystem); err != nil {
		return err
	}

	return nil
}

func (m *SnapshotSnapshotExtended) validatePctReserve(formats strfmt.Registry) error {

	if err := validate.Required("pct_reserve", "body", m.PctReserve); err != nil {
		return err
	}

	return nil
}

func (m *SnapshotSnapshotExtended) validateShadowBytes(formats strfmt.Registry) error {

	if err := validate.Required("shadow_bytes", "body", m.ShadowBytes); err != nil {
		return err
	}

	return nil
}

func (m *SnapshotSnapshotExtended) validateSize(formats strfmt.Registry) error {

	if err := validate.Required("size", "body", m.Size); err != nil {
		return err
	}

	return nil
}

var snapshotSnapshotExtendedTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["active","deleting"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		snapshotSnapshotExtendedTypeStatePropEnum = append(snapshotSnapshotExtendedTypeStatePropEnum, v)
	}
}

// property enum
func (m *SnapshotSnapshotExtended) validateStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, snapshotSnapshotExtendedTypeStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *SnapshotSnapshotExtended) validateState(formats strfmt.Registry) error {

	if err := validate.Required("state", "body", m.State); err != nil {
		return err
	}

	// value enum
	if err := m.validateStateEnum("state", "body", *m.State); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SnapshotSnapshotExtended) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SnapshotSnapshotExtended) UnmarshalBinary(b []byte) error {
	var res SnapshotSnapshotExtended
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
