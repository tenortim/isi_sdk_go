// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
)

// AuthIDNtoken auth Id ntoken
// swagger:model AuthIdNtoken
type AuthIDNtoken struct {

	// Specifies additional UIDs, GIDs, and SIDs.
	AdditionalID []*GroupMember `json:"additional_id"`

	// Specifies properties for a persona, which consists of either a 'type' and a 'name' or an 'ID'.
	Gid *GroupMember `json:"gid,omitempty"`

	// Specifies properties for a persona, which consists of either a 'type' and a 'name' or an 'ID'.
	GroupSid *GroupMember `json:"group_sid,omitempty"`

	// Indicates if this user has restricted access to the /ifs file system.
	IfsRestricted bool `json:"ifs_restricted,omitempty"`

	// Specifies the IP address of the node that is serving the request.
	LocalAddress string `json:"local_address,omitempty"`

	// Specifies properties for a persona, which consists of either a 'type' and a 'name' or an 'ID'.
	OnDiskGroupID *GroupMember `json:"on_disk_group_id,omitempty"`

	// Specifies properties for a persona, which consists of either a 'type' and a 'name' or an 'ID'.
	OnDiskUserID *GroupMember `json:"on_disk_user_id,omitempty"`

	// Specifies the privileges granted to the currently authenticated user.
	Privilege []*AuthIDNtokenPrivilegeItem `json:"privilege"`

	// Specifies the protocol that is responsible for the creation of the token. The integer values for each protcol are as follows: NFS (1), SMB (2), NLM (3), FTP (4), HTTP (5), ISCSI (7), SMB2 (8), NFS4 (9), OneFS API (10), HDFS (15), console (16), and SSH (17).
	Protocol int64 `json:"protocol,omitempty"`

	// Specifies the IP address of the client requesting information.
	RemoteAddress string `json:"remote_address,omitempty"`

	// Specifies properties for a persona, which consists of either a 'type' and a 'name' or an 'ID'.
	UID *GroupMember `json:"uid,omitempty"`

	// Specifies properties for a persona, which consists of either a 'type' and a 'name' or an 'ID'.
	UserSid *GroupMember `json:"user_sid,omitempty"`

	// Specifies the zone ID of the access zone that is serving the request.
	Zid int64 `json:"zid,omitempty"`

	// Specifies the name of the access zone that is serving the request.
	ZoneID string `json:"zone_id,omitempty"`
}

// Validate validates this auth Id ntoken
func (m *AuthIDNtoken) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAdditionalID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGid(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGroupSid(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOnDiskGroupID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOnDiskUserID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePrivilege(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserSid(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *AuthIDNtoken) validateAdditionalID(formats strfmt.Registry) error {

	if swag.IsZero(m.AdditionalID) { // not required
		return nil
	}

	for i := 0; i < len(m.AdditionalID); i++ {
		if swag.IsZero(m.AdditionalID[i]) { // not required
			continue
		}

		if m.AdditionalID[i] != nil {
			if err := m.AdditionalID[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("additional_id" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *AuthIDNtoken) validateGid(formats strfmt.Registry) error {

	if swag.IsZero(m.Gid) { // not required
		return nil
	}

	if m.Gid != nil {
		if err := m.Gid.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("gid")
			}
			return err
		}
	}

	return nil
}

func (m *AuthIDNtoken) validateGroupSid(formats strfmt.Registry) error {

	if swag.IsZero(m.GroupSid) { // not required
		return nil
	}

	if m.GroupSid != nil {
		if err := m.GroupSid.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("group_sid")
			}
			return err
		}
	}

	return nil
}

func (m *AuthIDNtoken) validateOnDiskGroupID(formats strfmt.Registry) error {

	if swag.IsZero(m.OnDiskGroupID) { // not required
		return nil
	}

	if m.OnDiskGroupID != nil {
		if err := m.OnDiskGroupID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("on_disk_group_id")
			}
			return err
		}
	}

	return nil
}

func (m *AuthIDNtoken) validateOnDiskUserID(formats strfmt.Registry) error {

	if swag.IsZero(m.OnDiskUserID) { // not required
		return nil
	}

	if m.OnDiskUserID != nil {
		if err := m.OnDiskUserID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("on_disk_user_id")
			}
			return err
		}
	}

	return nil
}

func (m *AuthIDNtoken) validatePrivilege(formats strfmt.Registry) error {

	if swag.IsZero(m.Privilege) { // not required
		return nil
	}

	for i := 0; i < len(m.Privilege); i++ {
		if swag.IsZero(m.Privilege[i]) { // not required
			continue
		}

		if m.Privilege[i] != nil {
			if err := m.Privilege[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("privilege" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *AuthIDNtoken) validateUID(formats strfmt.Registry) error {

	if swag.IsZero(m.UID) { // not required
		return nil
	}

	if m.UID != nil {
		if err := m.UID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("uid")
			}
			return err
		}
	}

	return nil
}

func (m *AuthIDNtoken) validateUserSid(formats strfmt.Registry) error {

	if swag.IsZero(m.UserSid) { // not required
		return nil
	}

	if m.UserSid != nil {
		if err := m.UserSid.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user_sid")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *AuthIDNtoken) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *AuthIDNtoken) UnmarshalBinary(b []byte) error {
	var res AuthIDNtoken
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
