// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// TargetReport target report
// swagger:model TargetReport
type TargetReport struct {

	// The action to be taken by this job.
	// Required: true
	// Enum: [resync_prep allow_write allow_write_revert test run]
	Action *string `json:"action"`

	// The number of ads streams replicated by this job.
	// Required: true
	AdsStreamsReplicated *int64 `json:"ads_streams_replicated"`

	// The number of block specs replicated by this job.
	// Required: true
	BlockSpecsReplicated *int64 `json:"block_specs_replicated"`

	// The number of bytes recoverable by this job.
	// Required: true
	BytesRecoverable *int64 `json:"bytes_recoverable"`

	// The number of bytes that have been transferred by this job.
	// Required: true
	BytesTransferred *int64 `json:"bytes_transferred"`

	// The number of char specs replicated by this job.
	// Required: true
	CharSpecsReplicated *int64 `json:"char_specs_replicated"`

	// The number of LINs corrected by this job.
	// Required: true
	CorrectedLins *int64 `json:"corrected_lins"`

	// This field is true if the node running this job is dead.
	// Required: true
	DeadNode *bool `json:"dead_node"`

	// The number of directories replicated.
	// Required: true
	DirectoriesReplicated *int64 `json:"directories_replicated"`

	// The number of directories changed by this job.
	// Required: true
	DirsChanged *int64 `json:"dirs_changed"`

	// The number of directories deleted by this job.
	// Required: true
	DirsDeleted *int64 `json:"dirs_deleted"`

	// The number of directories moved by this job.
	// Required: true
	DirsMoved *int64 `json:"dirs_moved"`

	// The number of directories created by this job.
	// Required: true
	DirsNew *int64 `json:"dirs_new"`

	// The amount of time in seconds between when the job was started and when it ended.  If the job has not yet ended, this is the amount of time since the job started.  This field is null if the job has not yet started.
	Duration int64 `json:"duration,omitempty"`

	// The time the job ended in unix epoch seconds. The field is null if the job hasn't ended.
	EndTime int64 `json:"end_time,omitempty"`

	// The primary error message for this job.
	// Required: true
	Error *string `json:"error"`

	// The number of files with checksum errors skipped by this job.
	// Required: true
	ErrorChecksumFilesSkipped *int64 `json:"error_checksum_files_skipped"`

	// The number of files with io errors skipped by this job.
	// Required: true
	ErrorIoFilesSkipped *int64 `json:"error_io_files_skipped"`

	// The number of files with network errors skipped by this job.
	// Required: true
	ErrorNetFilesSkipped *int64 `json:"error_net_files_skipped"`

	// A list of error messages for this job.
	// Required: true
	Errors []string `json:"errors"`

	// Tyhe number of data chunks that failed transmission.
	// Required: true
	FailedChunks *int64 `json:"failed_chunks"`

	// The number of fifos replicated by this job.
	// Required: true
	FifosReplicated *int64 `json:"fifos_replicated"`

	// The number of bytes transferred that belong to files.
	// Required: true
	FileDataBytes *int64 `json:"file_data_bytes"`

	// The number of files changed by this job.
	// Required: true
	FilesChanged *int64 `json:"files_changed"`

	// The number of files linked by this job.
	// Required: true
	FilesLinked *int64 `json:"files_linked"`

	// The number of files created by this job.
	// Required: true
	FilesNew *int64 `json:"files_new"`

	// The number of files selected by this job.
	// Required: true
	FilesSelected *int64 `json:"files_selected"`

	// The number of files transferred by this job.
	// Required: true
	FilesTransferred *int64 `json:"files_transferred"`

	// The number of files unlinked by this job.
	// Required: true
	FilesUnlinked *int64 `json:"files_unlinked"`

	// The number of files with ads replicated by this job.
	// Required: true
	FilesWithAdsReplicated *int64 `json:"files_with_ads_replicated"`

	// The number of LINs flipped by this job.
	// Required: true
	FlippedLins *int64 `json:"flipped_lins"`

	// The number of hard links replicated by this job.
	// Required: true
	HardLinksReplicated *int64 `json:"hard_links_replicated"`

	// The number of hash exceptions fixed by this job.
	// Required: true
	HashExceptionsFixed *int64 `json:"hash_exceptions_fixed"`

	// The number of hash exceptions found by this job.
	// Required: true
	HashExceptionsFound *int64 `json:"hash_exceptions_found"`

	// A unique identifier for this object.
	// Required: true
	ID *string `json:"id"`

	// The ID of the job.
	JobID int64 `json:"job_id,omitempty"`

	// The number of LINs transferred by this job.
	// Required: true
	LinsTotal *int64 `json:"lins_total"`

	// The total number of bytes sent to the source by this job.
	// Required: true
	NetworkBytesToSource *int64 `json:"network_bytes_to_source"`

	// The total number of bytes sent to the target by this job.
	// Required: true
	NetworkBytesToTarget *int64 `json:"network_bytes_to_target"`

	// The number of new files replicated by this job.
	// Required: true
	NewFilesReplicated *int64 `json:"new_files_replicated"`

	// The number of files that have been retransmitted by this job.
	// Required: true
	NumRetransmittedFiles *int64 `json:"num_retransmitted_files"`

	// Data for each phase of this job.
	// Required: true
	Phases []*ReportSubreportPhase `json:"phases"`

	// The ID of the policy.
	// Required: true
	PolicyID *string `json:"policy_id"`

	// The name of the policy.
	// Required: true
	PolicyName *string `json:"policy_name"`

	// The number of regular files replicated by this job.
	// Required: true
	RegularFilesReplicated *int64 `json:"regular_files_replicated"`

	// The number of LINs resynched by this job.
	// Required: true
	ResyncedLins *int64 `json:"resynced_lins"`

	// The files that have been retransmitted by this job.
	// Required: true
	RetransmittedFiles []string `json:"retransmitted_files"`

	// The number of times the job has been retried.
	// Required: true
	Retry *int64 `json:"retry"`

	// The number of data chunks currently being transmitted.
	// Required: true
	RunningChunks *int64 `json:"running_chunks"`

	// The number of sockets replicated by this job.
	// Required: true
	SocketsReplicated *int64 `json:"sockets_replicated"`

	// The number of bytes recovered on the source.
	// Required: true
	SourceBytesRecovered *int64 `json:"source_bytes_recovered"`

	// The number of directories created on the source.
	// Required: true
	SourceDirectoriesCreated *int64 `json:"source_directories_created"`

	// The number of directories deleted on the source.
	// Required: true
	SourceDirectoriesDeleted *int64 `json:"source_directories_deleted"`

	// The number of directories linked on the source.
	// Required: true
	SourceDirectoriesLinked *int64 `json:"source_directories_linked"`

	// The number of directories unlinked on the source.
	// Required: true
	SourceDirectoriesUnlinked *int64 `json:"source_directories_unlinked"`

	// The number of directories visited on the source.
	// Required: true
	SourceDirectoriesVisited *int64 `json:"source_directories_visited"`

	// The number of files deleted on the source.
	// Required: true
	SourceFilesDeleted *int64 `json:"source_files_deleted"`

	// The number of files linked on the source.
	// Required: true
	SourceFilesLinked *int64 `json:"source_files_linked"`

	// The number of files unlinked on the source.
	// Required: true
	SourceFilesUnlinked *int64 `json:"source_files_unlinked"`

	// Hostname or IP address of sync source cluster.
	// Required: true
	SourceHost *string `json:"source_host"`

	// The number of sparse data bytes transferred by this job.
	// Required: true
	SparseDataBytes *int64 `json:"sparse_data_bytes"`

	// The time the job started in unix epoch seconds. The field is null if the job hasn't started.
	StartTime int64 `json:"start_time,omitempty"`

	// The state of the job.
	// Required: true
	// Enum: [scheduled running paused finished failed canceled needs_attention skipped pending unknown]
	State *string `json:"state"`

	// The number of subreports that are available for this job report.
	// Required: true
	SubreportCount *int64 `json:"subreport_count"`

	// The number of data chunks that have been transmitted successfully.
	// Required: true
	SucceededChunks *int64 `json:"succeeded_chunks"`

	// The number of symlinks replicated by this job.
	// Required: true
	SymlinksReplicated *int64 `json:"symlinks_replicated"`

	// The type of sync being performed by this job.
	// Required: true
	// Enum: [invalid legacy initial incremental upgrade fofb domainmark]
	SyncType *string `json:"sync_type"`

	// The number of bytes recovered on the target.
	// Required: true
	TargetBytesRecovered *int64 `json:"target_bytes_recovered"`

	// The number of directories created on the target.
	// Required: true
	TargetDirectoriesCreated *int64 `json:"target_directories_created"`

	// The number of directories deleted on the target.
	// Required: true
	TargetDirectoriesDeleted *int64 `json:"target_directories_deleted"`

	// The number of directories linked on the target.
	// Required: true
	TargetDirectoriesLinked *int64 `json:"target_directories_linked"`

	// The number of directories unlinked on the target.
	// Required: true
	TargetDirectoriesUnlinked *int64 `json:"target_directories_unlinked"`

	// The number of files deleted on the target.
	// Required: true
	TargetFilesDeleted *int64 `json:"target_files_deleted"`

	// The number of files linked on the target.
	// Required: true
	TargetFilesLinked *int64 `json:"target_files_linked"`

	// The number of files unlinked on the target.
	// Required: true
	TargetFilesUnlinked *int64 `json:"target_files_unlinked"`

	// Absolute filesystem path on the target cluster for the sync destination.
	// Required: true
	TargetPath *string `json:"target_path"`

	// The target snapshots created by this job.
	// Required: true
	TargetSnapshots []string `json:"target_snapshots"`

	// The total number of data chunks transmitted by this job.
	// Required: true
	TotalChunks *int64 `json:"total_chunks"`

	// The total number of bytes transferred by this job.
	// Required: true
	TotalDataBytes *int64 `json:"total_data_bytes"`

	// The number of files affected by this job.
	// Required: true
	TotalFiles *int64 `json:"total_files"`

	// The total number of bytes sent over the network by this job.
	// Required: true
	TotalNetworkBytes *int64 `json:"total_network_bytes"`

	// The total number of phases for this job.
	// Required: true
	TotalPhases *int64 `json:"total_phases"`

	// The number of bytes unchanged by this job.
	// Required: true
	UnchangedDataBytes *int64 `json:"unchanged_data_bytes"`

	// The number of up-to-date files skipped by this job.
	// Required: true
	UpToDateFilesSkipped *int64 `json:"up_to_date_files_skipped"`

	// The number of updated files replicated by this job.
	// Required: true
	UpdatedFilesReplicated *int64 `json:"updated_files_replicated"`

	// The number of files with user conflicts skipped by this job.
	// Required: true
	UserConflictFilesSkipped *int64 `json:"user_conflict_files_skipped"`

	// A list of warning messages for this job.
	// Required: true
	Warnings []string `json:"warnings"`
}

// Validate validates this target report
func (m *TargetReport) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAction(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAdsStreamsReplicated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBlockSpecsReplicated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBytesRecoverable(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBytesTransferred(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCharSpecsReplicated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCorrectedLins(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDeadNode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDirectoriesReplicated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDirsChanged(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDirsDeleted(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDirsMoved(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDirsNew(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateError(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateErrorChecksumFilesSkipped(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateErrorIoFilesSkipped(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateErrorNetFilesSkipped(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateErrors(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFailedChunks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFifosReplicated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFileDataBytes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFilesChanged(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFilesLinked(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFilesNew(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFilesSelected(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFilesTransferred(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFilesUnlinked(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFilesWithAdsReplicated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFlippedLins(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHardLinksReplicated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHashExceptionsFixed(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHashExceptionsFound(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLinsTotal(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNetworkBytesToSource(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNetworkBytesToTarget(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNewFilesReplicated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNumRetransmittedFiles(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePhases(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePolicyID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePolicyName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRegularFilesReplicated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResyncedLins(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRetransmittedFiles(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRetry(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRunningChunks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSocketsReplicated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourceBytesRecovered(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourceDirectoriesCreated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourceDirectoriesDeleted(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourceDirectoriesLinked(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourceDirectoriesUnlinked(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourceDirectoriesVisited(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourceFilesDeleted(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourceFilesLinked(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourceFilesUnlinked(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSourceHost(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSparseDataBytes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSubreportCount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSucceededChunks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSymlinksReplicated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSyncType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTargetBytesRecovered(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTargetDirectoriesCreated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTargetDirectoriesDeleted(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTargetDirectoriesLinked(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTargetDirectoriesUnlinked(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTargetFilesDeleted(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTargetFilesLinked(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTargetFilesUnlinked(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTargetPath(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTargetSnapshots(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalChunks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalDataBytes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalFiles(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalNetworkBytes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotalPhases(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUnchangedDataBytes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpToDateFilesSkipped(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpdatedFilesReplicated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserConflictFilesSkipped(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateWarnings(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var targetReportTypeActionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["resync_prep","allow_write","allow_write_revert","test","run"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		targetReportTypeActionPropEnum = append(targetReportTypeActionPropEnum, v)
	}
}

const (

	// TargetReportActionResyncPrep captures enum value "resync_prep"
	TargetReportActionResyncPrep string = "resync_prep"

	// TargetReportActionAllowWrite captures enum value "allow_write"
	TargetReportActionAllowWrite string = "allow_write"

	// TargetReportActionAllowWriteRevert captures enum value "allow_write_revert"
	TargetReportActionAllowWriteRevert string = "allow_write_revert"

	// TargetReportActionTest captures enum value "test"
	TargetReportActionTest string = "test"

	// TargetReportActionRun captures enum value "run"
	TargetReportActionRun string = "run"
)

// prop value enum
func (m *TargetReport) validateActionEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, targetReportTypeActionPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *TargetReport) validateAction(formats strfmt.Registry) error {

	if err := validate.Required("action", "body", m.Action); err != nil {
		return err
	}

	// value enum
	if err := m.validateActionEnum("action", "body", *m.Action); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateAdsStreamsReplicated(formats strfmt.Registry) error {

	if err := validate.Required("ads_streams_replicated", "body", m.AdsStreamsReplicated); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateBlockSpecsReplicated(formats strfmt.Registry) error {

	if err := validate.Required("block_specs_replicated", "body", m.BlockSpecsReplicated); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateBytesRecoverable(formats strfmt.Registry) error {

	if err := validate.Required("bytes_recoverable", "body", m.BytesRecoverable); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateBytesTransferred(formats strfmt.Registry) error {

	if err := validate.Required("bytes_transferred", "body", m.BytesTransferred); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateCharSpecsReplicated(formats strfmt.Registry) error {

	if err := validate.Required("char_specs_replicated", "body", m.CharSpecsReplicated); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateCorrectedLins(formats strfmt.Registry) error {

	if err := validate.Required("corrected_lins", "body", m.CorrectedLins); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateDeadNode(formats strfmt.Registry) error {

	if err := validate.Required("dead_node", "body", m.DeadNode); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateDirectoriesReplicated(formats strfmt.Registry) error {

	if err := validate.Required("directories_replicated", "body", m.DirectoriesReplicated); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateDirsChanged(formats strfmt.Registry) error {

	if err := validate.Required("dirs_changed", "body", m.DirsChanged); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateDirsDeleted(formats strfmt.Registry) error {

	if err := validate.Required("dirs_deleted", "body", m.DirsDeleted); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateDirsMoved(formats strfmt.Registry) error {

	if err := validate.Required("dirs_moved", "body", m.DirsMoved); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateDirsNew(formats strfmt.Registry) error {

	if err := validate.Required("dirs_new", "body", m.DirsNew); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateError(formats strfmt.Registry) error {

	if err := validate.Required("error", "body", m.Error); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateErrorChecksumFilesSkipped(formats strfmt.Registry) error {

	if err := validate.Required("error_checksum_files_skipped", "body", m.ErrorChecksumFilesSkipped); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateErrorIoFilesSkipped(formats strfmt.Registry) error {

	if err := validate.Required("error_io_files_skipped", "body", m.ErrorIoFilesSkipped); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateErrorNetFilesSkipped(formats strfmt.Registry) error {

	if err := validate.Required("error_net_files_skipped", "body", m.ErrorNetFilesSkipped); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateErrors(formats strfmt.Registry) error {

	if err := validate.Required("errors", "body", m.Errors); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateFailedChunks(formats strfmt.Registry) error {

	if err := validate.Required("failed_chunks", "body", m.FailedChunks); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateFifosReplicated(formats strfmt.Registry) error {

	if err := validate.Required("fifos_replicated", "body", m.FifosReplicated); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateFileDataBytes(formats strfmt.Registry) error {

	if err := validate.Required("file_data_bytes", "body", m.FileDataBytes); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateFilesChanged(formats strfmt.Registry) error {

	if err := validate.Required("files_changed", "body", m.FilesChanged); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateFilesLinked(formats strfmt.Registry) error {

	if err := validate.Required("files_linked", "body", m.FilesLinked); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateFilesNew(formats strfmt.Registry) error {

	if err := validate.Required("files_new", "body", m.FilesNew); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateFilesSelected(formats strfmt.Registry) error {

	if err := validate.Required("files_selected", "body", m.FilesSelected); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateFilesTransferred(formats strfmt.Registry) error {

	if err := validate.Required("files_transferred", "body", m.FilesTransferred); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateFilesUnlinked(formats strfmt.Registry) error {

	if err := validate.Required("files_unlinked", "body", m.FilesUnlinked); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateFilesWithAdsReplicated(formats strfmt.Registry) error {

	if err := validate.Required("files_with_ads_replicated", "body", m.FilesWithAdsReplicated); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateFlippedLins(formats strfmt.Registry) error {

	if err := validate.Required("flipped_lins", "body", m.FlippedLins); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateHardLinksReplicated(formats strfmt.Registry) error {

	if err := validate.Required("hard_links_replicated", "body", m.HardLinksReplicated); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateHashExceptionsFixed(formats strfmt.Registry) error {

	if err := validate.Required("hash_exceptions_fixed", "body", m.HashExceptionsFixed); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateHashExceptionsFound(formats strfmt.Registry) error {

	if err := validate.Required("hash_exceptions_found", "body", m.HashExceptionsFound); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateLinsTotal(formats strfmt.Registry) error {

	if err := validate.Required("lins_total", "body", m.LinsTotal); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateNetworkBytesToSource(formats strfmt.Registry) error {

	if err := validate.Required("network_bytes_to_source", "body", m.NetworkBytesToSource); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateNetworkBytesToTarget(formats strfmt.Registry) error {

	if err := validate.Required("network_bytes_to_target", "body", m.NetworkBytesToTarget); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateNewFilesReplicated(formats strfmt.Registry) error {

	if err := validate.Required("new_files_replicated", "body", m.NewFilesReplicated); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateNumRetransmittedFiles(formats strfmt.Registry) error {

	if err := validate.Required("num_retransmitted_files", "body", m.NumRetransmittedFiles); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validatePhases(formats strfmt.Registry) error {

	if err := validate.Required("phases", "body", m.Phases); err != nil {
		return err
	}

	for i := 0; i < len(m.Phases); i++ {
		if swag.IsZero(m.Phases[i]) { // not required
			continue
		}

		if m.Phases[i] != nil {
			if err := m.Phases[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("phases" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TargetReport) validatePolicyID(formats strfmt.Registry) error {

	if err := validate.Required("policy_id", "body", m.PolicyID); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validatePolicyName(formats strfmt.Registry) error {

	if err := validate.Required("policy_name", "body", m.PolicyName); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateRegularFilesReplicated(formats strfmt.Registry) error {

	if err := validate.Required("regular_files_replicated", "body", m.RegularFilesReplicated); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateResyncedLins(formats strfmt.Registry) error {

	if err := validate.Required("resynced_lins", "body", m.ResyncedLins); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateRetransmittedFiles(formats strfmt.Registry) error {

	if err := validate.Required("retransmitted_files", "body", m.RetransmittedFiles); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateRetry(formats strfmt.Registry) error {

	if err := validate.Required("retry", "body", m.Retry); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateRunningChunks(formats strfmt.Registry) error {

	if err := validate.Required("running_chunks", "body", m.RunningChunks); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateSocketsReplicated(formats strfmt.Registry) error {

	if err := validate.Required("sockets_replicated", "body", m.SocketsReplicated); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateSourceBytesRecovered(formats strfmt.Registry) error {

	if err := validate.Required("source_bytes_recovered", "body", m.SourceBytesRecovered); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateSourceDirectoriesCreated(formats strfmt.Registry) error {

	if err := validate.Required("source_directories_created", "body", m.SourceDirectoriesCreated); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateSourceDirectoriesDeleted(formats strfmt.Registry) error {

	if err := validate.Required("source_directories_deleted", "body", m.SourceDirectoriesDeleted); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateSourceDirectoriesLinked(formats strfmt.Registry) error {

	if err := validate.Required("source_directories_linked", "body", m.SourceDirectoriesLinked); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateSourceDirectoriesUnlinked(formats strfmt.Registry) error {

	if err := validate.Required("source_directories_unlinked", "body", m.SourceDirectoriesUnlinked); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateSourceDirectoriesVisited(formats strfmt.Registry) error {

	if err := validate.Required("source_directories_visited", "body", m.SourceDirectoriesVisited); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateSourceFilesDeleted(formats strfmt.Registry) error {

	if err := validate.Required("source_files_deleted", "body", m.SourceFilesDeleted); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateSourceFilesLinked(formats strfmt.Registry) error {

	if err := validate.Required("source_files_linked", "body", m.SourceFilesLinked); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateSourceFilesUnlinked(formats strfmt.Registry) error {

	if err := validate.Required("source_files_unlinked", "body", m.SourceFilesUnlinked); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateSourceHost(formats strfmt.Registry) error {

	if err := validate.Required("source_host", "body", m.SourceHost); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateSparseDataBytes(formats strfmt.Registry) error {

	if err := validate.Required("sparse_data_bytes", "body", m.SparseDataBytes); err != nil {
		return err
	}

	return nil
}

var targetReportTypeStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["scheduled","running","paused","finished","failed","canceled","needs_attention","skipped","pending","unknown"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		targetReportTypeStatePropEnum = append(targetReportTypeStatePropEnum, v)
	}
}

const (

	// TargetReportStateScheduled captures enum value "scheduled"
	TargetReportStateScheduled string = "scheduled"

	// TargetReportStateRunning captures enum value "running"
	TargetReportStateRunning string = "running"

	// TargetReportStatePaused captures enum value "paused"
	TargetReportStatePaused string = "paused"

	// TargetReportStateFinished captures enum value "finished"
	TargetReportStateFinished string = "finished"

	// TargetReportStateFailed captures enum value "failed"
	TargetReportStateFailed string = "failed"

	// TargetReportStateCanceled captures enum value "canceled"
	TargetReportStateCanceled string = "canceled"

	// TargetReportStateNeedsAttention captures enum value "needs_attention"
	TargetReportStateNeedsAttention string = "needs_attention"

	// TargetReportStateSkipped captures enum value "skipped"
	TargetReportStateSkipped string = "skipped"

	// TargetReportStatePending captures enum value "pending"
	TargetReportStatePending string = "pending"

	// TargetReportStateUnknown captures enum value "unknown"
	TargetReportStateUnknown string = "unknown"
)

// prop value enum
func (m *TargetReport) validateStateEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, targetReportTypeStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *TargetReport) validateState(formats strfmt.Registry) error {

	if err := validate.Required("state", "body", m.State); err != nil {
		return err
	}

	// value enum
	if err := m.validateStateEnum("state", "body", *m.State); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateSubreportCount(formats strfmt.Registry) error {

	if err := validate.Required("subreport_count", "body", m.SubreportCount); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateSucceededChunks(formats strfmt.Registry) error {

	if err := validate.Required("succeeded_chunks", "body", m.SucceededChunks); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateSymlinksReplicated(formats strfmt.Registry) error {

	if err := validate.Required("symlinks_replicated", "body", m.SymlinksReplicated); err != nil {
		return err
	}

	return nil
}

var targetReportTypeSyncTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["invalid","legacy","initial","incremental","upgrade","fofb","domainmark"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		targetReportTypeSyncTypePropEnum = append(targetReportTypeSyncTypePropEnum, v)
	}
}

const (

	// TargetReportSyncTypeInvalid captures enum value "invalid"
	TargetReportSyncTypeInvalid string = "invalid"

	// TargetReportSyncTypeLegacy captures enum value "legacy"
	TargetReportSyncTypeLegacy string = "legacy"

	// TargetReportSyncTypeInitial captures enum value "initial"
	TargetReportSyncTypeInitial string = "initial"

	// TargetReportSyncTypeIncremental captures enum value "incremental"
	TargetReportSyncTypeIncremental string = "incremental"

	// TargetReportSyncTypeUpgrade captures enum value "upgrade"
	TargetReportSyncTypeUpgrade string = "upgrade"

	// TargetReportSyncTypeFofb captures enum value "fofb"
	TargetReportSyncTypeFofb string = "fofb"

	// TargetReportSyncTypeDomainmark captures enum value "domainmark"
	TargetReportSyncTypeDomainmark string = "domainmark"
)

// prop value enum
func (m *TargetReport) validateSyncTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, targetReportTypeSyncTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *TargetReport) validateSyncType(formats strfmt.Registry) error {

	if err := validate.Required("sync_type", "body", m.SyncType); err != nil {
		return err
	}

	// value enum
	if err := m.validateSyncTypeEnum("sync_type", "body", *m.SyncType); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateTargetBytesRecovered(formats strfmt.Registry) error {

	if err := validate.Required("target_bytes_recovered", "body", m.TargetBytesRecovered); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateTargetDirectoriesCreated(formats strfmt.Registry) error {

	if err := validate.Required("target_directories_created", "body", m.TargetDirectoriesCreated); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateTargetDirectoriesDeleted(formats strfmt.Registry) error {

	if err := validate.Required("target_directories_deleted", "body", m.TargetDirectoriesDeleted); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateTargetDirectoriesLinked(formats strfmt.Registry) error {

	if err := validate.Required("target_directories_linked", "body", m.TargetDirectoriesLinked); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateTargetDirectoriesUnlinked(formats strfmt.Registry) error {

	if err := validate.Required("target_directories_unlinked", "body", m.TargetDirectoriesUnlinked); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateTargetFilesDeleted(formats strfmt.Registry) error {

	if err := validate.Required("target_files_deleted", "body", m.TargetFilesDeleted); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateTargetFilesLinked(formats strfmt.Registry) error {

	if err := validate.Required("target_files_linked", "body", m.TargetFilesLinked); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateTargetFilesUnlinked(formats strfmt.Registry) error {

	if err := validate.Required("target_files_unlinked", "body", m.TargetFilesUnlinked); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateTargetPath(formats strfmt.Registry) error {

	if err := validate.Required("target_path", "body", m.TargetPath); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateTargetSnapshots(formats strfmt.Registry) error {

	if err := validate.Required("target_snapshots", "body", m.TargetSnapshots); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateTotalChunks(formats strfmt.Registry) error {

	if err := validate.Required("total_chunks", "body", m.TotalChunks); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateTotalDataBytes(formats strfmt.Registry) error {

	if err := validate.Required("total_data_bytes", "body", m.TotalDataBytes); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateTotalFiles(formats strfmt.Registry) error {

	if err := validate.Required("total_files", "body", m.TotalFiles); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateTotalNetworkBytes(formats strfmt.Registry) error {

	if err := validate.Required("total_network_bytes", "body", m.TotalNetworkBytes); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateTotalPhases(formats strfmt.Registry) error {

	if err := validate.Required("total_phases", "body", m.TotalPhases); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateUnchangedDataBytes(formats strfmt.Registry) error {

	if err := validate.Required("unchanged_data_bytes", "body", m.UnchangedDataBytes); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateUpToDateFilesSkipped(formats strfmt.Registry) error {

	if err := validate.Required("up_to_date_files_skipped", "body", m.UpToDateFilesSkipped); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateUpdatedFilesReplicated(formats strfmt.Registry) error {

	if err := validate.Required("updated_files_replicated", "body", m.UpdatedFilesReplicated); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateUserConflictFilesSkipped(formats strfmt.Registry) error {

	if err := validate.Required("user_conflict_files_skipped", "body", m.UserConflictFilesSkipped); err != nil {
		return err
	}

	return nil
}

func (m *TargetReport) validateWarnings(formats strfmt.Registry) error {

	if err := validate.Required("warnings", "body", m.Warnings); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TargetReport) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TargetReport) UnmarshalBinary(b []byte) error {
	var res TargetReport
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
