// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// SubnetsSubnetPoolsPool subnets subnet pools pool
// swagger:model SubnetsSubnetPoolsPool
type SubnetsSubnetPoolsPool struct {

	// Name of a valid access zone to map IP address pool to the zone.
	// Required: true
	// Min Length: 1
	AccessZone *string `json:"access_zone"`

	// IP address format.
	// Required: true
	// Enum: [ipv4 ipv6]
	AddrFamily *string `json:"addr_family"`

	// OneFS supports the following NIC aggregation modes.
	// Required: true
	// Enum: [roundrobin failover lacp fec]
	AggregationMode *string `json:"aggregation_mode"`

	// Specifies how IP address allocation is done among pool members.
	// Required: true
	// Enum: [dynamic static]
	AllocMethod *string `json:"alloc_method"`

	// A description of the pool.
	// Required: true
	// Max Length: 128
	Description *string `json:"description"`

	// Name of the groupnet this pool belongs to.
	// Required: true
	Groupnet *string `json:"groupnet"`

	// Unique Pool ID.
	// Required: true
	ID *string `json:"id"`

	// List of interface members in this pool.
	// Required: true
	Ifaces []*SubnetsSubnetPoolIface `json:"ifaces"`

	// The name of the pool. It must be unique throughout the given subnet.It's a required field with POST method.
	// Required: true
	// Max Length: 32
	Name *string `json:"name"`

	// List of IP address ranges in this pool.
	// Required: true
	Ranges []*SubnetsSubnetPoolRange `json:"ranges"`

	// Rebalance policy..
	// Required: true
	// Enum: [auto manual]
	RebalancePolicy *string `json:"rebalance_policy"`

	// Names of the rules in this pool.
	// Required: true
	Rules []string `json:"rules"`

	// Time delay in seconds before a node which has been                 automatically unsuspended becomes usable in SmartConnect                responses for pool zones.
	// Required: true
	// Maximum: 86400
	// Minimum: 0
	ScAutoUnsuspendDelay *int64 `json:"sc_auto_unsuspend_delay"`

	// SmartConnect client connection balancing policy.
	// Required: true
	// Enum: [round_robin conn_count throughput cpu_usage]
	ScConnectPolicy *string `json:"sc_connect_policy"`

	// SmartConnect zone name for the pool.
	// Required: true
	ScDNSZone *string `json:"sc_dns_zone"`

	// List of SmartConnect zone aliases (DNS names) to the pool.
	// Required: true
	ScDNSZoneAliases []string `json:"sc_dns_zone_aliases"`

	// SmartConnect IP failover policy.
	// Required: true
	// Enum: [round_robin conn_count throughput cpu_usage]
	ScFailoverPolicy *string `json:"sc_failover_policy"`

	// Name of SmartConnect service subnet for this pool.
	// Required: true
	ScSubnet *string `json:"sc_subnet"`

	// List of LNNs showing currently suspended nodes in SmartConnect.
	// Required: true
	ScSuspendedNodes []int64 `json:"sc_suspended_nodes"`

	// Time to live value for SmartConnect DNS query responses in seconds.
	// Required: true
	// Maximum: 2.147483647e+09
	// Minimum: 0
	ScTTL *int64 `json:"sc_ttl"`

	// List of interface members in this pool.
	// Required: true
	StaticRoutes []*SubnetsSubnetPoolStaticRoute `json:"static_routes"`

	// The name of the subnet.
	// Required: true
	Subnet *string `json:"subnet"`
}

// Validate validates this subnets subnet pools pool
func (m *SubnetsSubnetPoolsPool) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAccessZone(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAddrFamily(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAggregationMode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAllocMethod(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDescription(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGroupnet(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIfaces(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRanges(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRebalancePolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRules(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScAutoUnsuspendDelay(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScConnectPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScDNSZone(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScDNSZoneAliases(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScFailoverPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScSubnet(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScSuspendedNodes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateScTTL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStaticRoutes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSubnet(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SubnetsSubnetPoolsPool) validateAccessZone(formats strfmt.Registry) error {

	if err := validate.Required("access_zone", "body", m.AccessZone); err != nil {
		return err
	}

	if err := validate.MinLength("access_zone", "body", string(*m.AccessZone), 1); err != nil {
		return err
	}

	return nil
}

var subnetsSubnetPoolsPoolTypeAddrFamilyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["ipv4","ipv6"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		subnetsSubnetPoolsPoolTypeAddrFamilyPropEnum = append(subnetsSubnetPoolsPoolTypeAddrFamilyPropEnum, v)
	}
}

const (

	// SubnetsSubnetPoolsPoolAddrFamilyIPV4 captures enum value "ipv4"
	SubnetsSubnetPoolsPoolAddrFamilyIPV4 string = "ipv4"

	// SubnetsSubnetPoolsPoolAddrFamilyIPV6 captures enum value "ipv6"
	SubnetsSubnetPoolsPoolAddrFamilyIPV6 string = "ipv6"
)

// prop value enum
func (m *SubnetsSubnetPoolsPool) validateAddrFamilyEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, subnetsSubnetPoolsPoolTypeAddrFamilyPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *SubnetsSubnetPoolsPool) validateAddrFamily(formats strfmt.Registry) error {

	if err := validate.Required("addr_family", "body", m.AddrFamily); err != nil {
		return err
	}

	// value enum
	if err := m.validateAddrFamilyEnum("addr_family", "body", *m.AddrFamily); err != nil {
		return err
	}

	return nil
}

var subnetsSubnetPoolsPoolTypeAggregationModePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["roundrobin","failover","lacp","fec"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		subnetsSubnetPoolsPoolTypeAggregationModePropEnum = append(subnetsSubnetPoolsPoolTypeAggregationModePropEnum, v)
	}
}

const (

	// SubnetsSubnetPoolsPoolAggregationModeRoundrobin captures enum value "roundrobin"
	SubnetsSubnetPoolsPoolAggregationModeRoundrobin string = "roundrobin"

	// SubnetsSubnetPoolsPoolAggregationModeFailover captures enum value "failover"
	SubnetsSubnetPoolsPoolAggregationModeFailover string = "failover"

	// SubnetsSubnetPoolsPoolAggregationModeLacp captures enum value "lacp"
	SubnetsSubnetPoolsPoolAggregationModeLacp string = "lacp"

	// SubnetsSubnetPoolsPoolAggregationModeFec captures enum value "fec"
	SubnetsSubnetPoolsPoolAggregationModeFec string = "fec"
)

// prop value enum
func (m *SubnetsSubnetPoolsPool) validateAggregationModeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, subnetsSubnetPoolsPoolTypeAggregationModePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *SubnetsSubnetPoolsPool) validateAggregationMode(formats strfmt.Registry) error {

	if err := validate.Required("aggregation_mode", "body", m.AggregationMode); err != nil {
		return err
	}

	// value enum
	if err := m.validateAggregationModeEnum("aggregation_mode", "body", *m.AggregationMode); err != nil {
		return err
	}

	return nil
}

var subnetsSubnetPoolsPoolTypeAllocMethodPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["dynamic","static"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		subnetsSubnetPoolsPoolTypeAllocMethodPropEnum = append(subnetsSubnetPoolsPoolTypeAllocMethodPropEnum, v)
	}
}

const (

	// SubnetsSubnetPoolsPoolAllocMethodDynamic captures enum value "dynamic"
	SubnetsSubnetPoolsPoolAllocMethodDynamic string = "dynamic"

	// SubnetsSubnetPoolsPoolAllocMethodStatic captures enum value "static"
	SubnetsSubnetPoolsPoolAllocMethodStatic string = "static"
)

// prop value enum
func (m *SubnetsSubnetPoolsPool) validateAllocMethodEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, subnetsSubnetPoolsPoolTypeAllocMethodPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *SubnetsSubnetPoolsPool) validateAllocMethod(formats strfmt.Registry) error {

	if err := validate.Required("alloc_method", "body", m.AllocMethod); err != nil {
		return err
	}

	// value enum
	if err := m.validateAllocMethodEnum("alloc_method", "body", *m.AllocMethod); err != nil {
		return err
	}

	return nil
}

func (m *SubnetsSubnetPoolsPool) validateDescription(formats strfmt.Registry) error {

	if err := validate.Required("description", "body", m.Description); err != nil {
		return err
	}

	if err := validate.MaxLength("description", "body", string(*m.Description), 128); err != nil {
		return err
	}

	return nil
}

func (m *SubnetsSubnetPoolsPool) validateGroupnet(formats strfmt.Registry) error {

	if err := validate.Required("groupnet", "body", m.Groupnet); err != nil {
		return err
	}

	return nil
}

func (m *SubnetsSubnetPoolsPool) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

func (m *SubnetsSubnetPoolsPool) validateIfaces(formats strfmt.Registry) error {

	if err := validate.Required("ifaces", "body", m.Ifaces); err != nil {
		return err
	}

	for i := 0; i < len(m.Ifaces); i++ {
		if swag.IsZero(m.Ifaces[i]) { // not required
			continue
		}

		if m.Ifaces[i] != nil {
			if err := m.Ifaces[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ifaces" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *SubnetsSubnetPoolsPool) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	if err := validate.MaxLength("name", "body", string(*m.Name), 32); err != nil {
		return err
	}

	return nil
}

func (m *SubnetsSubnetPoolsPool) validateRanges(formats strfmt.Registry) error {

	if err := validate.Required("ranges", "body", m.Ranges); err != nil {
		return err
	}

	for i := 0; i < len(m.Ranges); i++ {
		if swag.IsZero(m.Ranges[i]) { // not required
			continue
		}

		if m.Ranges[i] != nil {
			if err := m.Ranges[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ranges" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var subnetsSubnetPoolsPoolTypeRebalancePolicyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["auto","manual"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		subnetsSubnetPoolsPoolTypeRebalancePolicyPropEnum = append(subnetsSubnetPoolsPoolTypeRebalancePolicyPropEnum, v)
	}
}

const (

	// SubnetsSubnetPoolsPoolRebalancePolicyAuto captures enum value "auto"
	SubnetsSubnetPoolsPoolRebalancePolicyAuto string = "auto"

	// SubnetsSubnetPoolsPoolRebalancePolicyManual captures enum value "manual"
	SubnetsSubnetPoolsPoolRebalancePolicyManual string = "manual"
)

// prop value enum
func (m *SubnetsSubnetPoolsPool) validateRebalancePolicyEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, subnetsSubnetPoolsPoolTypeRebalancePolicyPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *SubnetsSubnetPoolsPool) validateRebalancePolicy(formats strfmt.Registry) error {

	if err := validate.Required("rebalance_policy", "body", m.RebalancePolicy); err != nil {
		return err
	}

	// value enum
	if err := m.validateRebalancePolicyEnum("rebalance_policy", "body", *m.RebalancePolicy); err != nil {
		return err
	}

	return nil
}

func (m *SubnetsSubnetPoolsPool) validateRules(formats strfmt.Registry) error {

	if err := validate.Required("rules", "body", m.Rules); err != nil {
		return err
	}

	return nil
}

func (m *SubnetsSubnetPoolsPool) validateScAutoUnsuspendDelay(formats strfmt.Registry) error {

	if err := validate.Required("sc_auto_unsuspend_delay", "body", m.ScAutoUnsuspendDelay); err != nil {
		return err
	}

	if err := validate.MinimumInt("sc_auto_unsuspend_delay", "body", int64(*m.ScAutoUnsuspendDelay), 0, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("sc_auto_unsuspend_delay", "body", int64(*m.ScAutoUnsuspendDelay), 86400, false); err != nil {
		return err
	}

	return nil
}

var subnetsSubnetPoolsPoolTypeScConnectPolicyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["round_robin","conn_count","throughput","cpu_usage"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		subnetsSubnetPoolsPoolTypeScConnectPolicyPropEnum = append(subnetsSubnetPoolsPoolTypeScConnectPolicyPropEnum, v)
	}
}

const (

	// SubnetsSubnetPoolsPoolScConnectPolicyRoundRobin captures enum value "round_robin"
	SubnetsSubnetPoolsPoolScConnectPolicyRoundRobin string = "round_robin"

	// SubnetsSubnetPoolsPoolScConnectPolicyConnCount captures enum value "conn_count"
	SubnetsSubnetPoolsPoolScConnectPolicyConnCount string = "conn_count"

	// SubnetsSubnetPoolsPoolScConnectPolicyThroughput captures enum value "throughput"
	SubnetsSubnetPoolsPoolScConnectPolicyThroughput string = "throughput"

	// SubnetsSubnetPoolsPoolScConnectPolicyCPUUsage captures enum value "cpu_usage"
	SubnetsSubnetPoolsPoolScConnectPolicyCPUUsage string = "cpu_usage"
)

// prop value enum
func (m *SubnetsSubnetPoolsPool) validateScConnectPolicyEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, subnetsSubnetPoolsPoolTypeScConnectPolicyPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *SubnetsSubnetPoolsPool) validateScConnectPolicy(formats strfmt.Registry) error {

	if err := validate.Required("sc_connect_policy", "body", m.ScConnectPolicy); err != nil {
		return err
	}

	// value enum
	if err := m.validateScConnectPolicyEnum("sc_connect_policy", "body", *m.ScConnectPolicy); err != nil {
		return err
	}

	return nil
}

func (m *SubnetsSubnetPoolsPool) validateScDNSZone(formats strfmt.Registry) error {

	if err := validate.Required("sc_dns_zone", "body", m.ScDNSZone); err != nil {
		return err
	}

	return nil
}

func (m *SubnetsSubnetPoolsPool) validateScDNSZoneAliases(formats strfmt.Registry) error {

	if err := validate.Required("sc_dns_zone_aliases", "body", m.ScDNSZoneAliases); err != nil {
		return err
	}

	return nil
}

var subnetsSubnetPoolsPoolTypeScFailoverPolicyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["round_robin","conn_count","throughput","cpu_usage"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		subnetsSubnetPoolsPoolTypeScFailoverPolicyPropEnum = append(subnetsSubnetPoolsPoolTypeScFailoverPolicyPropEnum, v)
	}
}

const (

	// SubnetsSubnetPoolsPoolScFailoverPolicyRoundRobin captures enum value "round_robin"
	SubnetsSubnetPoolsPoolScFailoverPolicyRoundRobin string = "round_robin"

	// SubnetsSubnetPoolsPoolScFailoverPolicyConnCount captures enum value "conn_count"
	SubnetsSubnetPoolsPoolScFailoverPolicyConnCount string = "conn_count"

	// SubnetsSubnetPoolsPoolScFailoverPolicyThroughput captures enum value "throughput"
	SubnetsSubnetPoolsPoolScFailoverPolicyThroughput string = "throughput"

	// SubnetsSubnetPoolsPoolScFailoverPolicyCPUUsage captures enum value "cpu_usage"
	SubnetsSubnetPoolsPoolScFailoverPolicyCPUUsage string = "cpu_usage"
)

// prop value enum
func (m *SubnetsSubnetPoolsPool) validateScFailoverPolicyEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, subnetsSubnetPoolsPoolTypeScFailoverPolicyPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *SubnetsSubnetPoolsPool) validateScFailoverPolicy(formats strfmt.Registry) error {

	if err := validate.Required("sc_failover_policy", "body", m.ScFailoverPolicy); err != nil {
		return err
	}

	// value enum
	if err := m.validateScFailoverPolicyEnum("sc_failover_policy", "body", *m.ScFailoverPolicy); err != nil {
		return err
	}

	return nil
}

func (m *SubnetsSubnetPoolsPool) validateScSubnet(formats strfmt.Registry) error {

	if err := validate.Required("sc_subnet", "body", m.ScSubnet); err != nil {
		return err
	}

	return nil
}

func (m *SubnetsSubnetPoolsPool) validateScSuspendedNodes(formats strfmt.Registry) error {

	if err := validate.Required("sc_suspended_nodes", "body", m.ScSuspendedNodes); err != nil {
		return err
	}

	return nil
}

func (m *SubnetsSubnetPoolsPool) validateScTTL(formats strfmt.Registry) error {

	if err := validate.Required("sc_ttl", "body", m.ScTTL); err != nil {
		return err
	}

	if err := validate.MinimumInt("sc_ttl", "body", int64(*m.ScTTL), 0, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("sc_ttl", "body", int64(*m.ScTTL), 2.147483647e+09, false); err != nil {
		return err
	}

	return nil
}

func (m *SubnetsSubnetPoolsPool) validateStaticRoutes(formats strfmt.Registry) error {

	if err := validate.Required("static_routes", "body", m.StaticRoutes); err != nil {
		return err
	}

	for i := 0; i < len(m.StaticRoutes); i++ {
		if swag.IsZero(m.StaticRoutes[i]) { // not required
			continue
		}

		if m.StaticRoutes[i] != nil {
			if err := m.StaticRoutes[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("static_routes" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *SubnetsSubnetPoolsPool) validateSubnet(formats strfmt.Registry) error {

	if err := validate.Required("subnet", "body", m.Subnet); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SubnetsSubnetPoolsPool) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SubnetsSubnetPoolsPool) UnmarshalBinary(b []byte) error {
	var res SubnetsSubnetPoolsPool
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
