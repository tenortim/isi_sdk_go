// Code generated by go-swagger; DO NOT EDIT.

package upgrade

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new upgrade API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for upgrade API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
CreateClusterAddRemainingNode Let system absorb any remaining or new nodes inside the existing upgrade.
*/
func (a *Client) CreateClusterAddRemainingNode(params *CreateClusterAddRemainingNodeParams, authInfo runtime.ClientAuthInfoWriter) (*CreateClusterAddRemainingNodeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateClusterAddRemainingNodeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createClusterAddRemainingNode",
		Method:             "POST",
		PathPattern:        "/platform/3/upgrade/cluster/add_remaining_nodes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateClusterAddRemainingNodeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateClusterAddRemainingNodeOK), nil

}

/*
CreateClusterArchiveItem Start an archive of an upgrade.
*/
func (a *Client) CreateClusterArchiveItem(params *CreateClusterArchiveItemParams, authInfo runtime.ClientAuthInfoWriter) (*CreateClusterArchiveItemOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateClusterArchiveItemParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createClusterArchiveItem",
		Method:             "POST",
		PathPattern:        "/platform/3/upgrade/cluster/archive",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateClusterArchiveItemReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateClusterArchiveItemOK), nil

}

/*
CreateClusterAssessItem Start upgrade assessment on cluster.
*/
func (a *Client) CreateClusterAssessItem(params *CreateClusterAssessItemParams, authInfo runtime.ClientAuthInfoWriter) (*CreateClusterAssessItemOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateClusterAssessItemParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createClusterAssessItem",
		Method:             "POST",
		PathPattern:        "/platform/3/upgrade/cluster/assess",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateClusterAssessItemReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateClusterAssessItemOK), nil

}

/*
CreateClusterCommitItem Commit the upgrade of a cluster.
*/
func (a *Client) CreateClusterCommitItem(params *CreateClusterCommitItemParams, authInfo runtime.ClientAuthInfoWriter) (*CreateClusterCommitItemOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateClusterCommitItemParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createClusterCommitItem",
		Method:             "POST",
		PathPattern:        "/platform/3/upgrade/cluster/commit",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateClusterCommitItemReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateClusterCommitItemOK), nil

}

/*
CreateClusterFirmwareAssessItem Start firmware upgrade assessment on cluster.
*/
func (a *Client) CreateClusterFirmwareAssessItem(params *CreateClusterFirmwareAssessItemParams, authInfo runtime.ClientAuthInfoWriter) (*CreateClusterFirmwareAssessItemOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateClusterFirmwareAssessItemParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createClusterFirmwareAssessItem",
		Method:             "POST",
		PathPattern:        "/platform/3/upgrade/cluster/firmware/assess",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateClusterFirmwareAssessItemReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateClusterFirmwareAssessItemOK), nil

}

/*
CreateClusterFirmwareUpgradeItem The settings necessary to start a firmware upgrade.
*/
func (a *Client) CreateClusterFirmwareUpgradeItem(params *CreateClusterFirmwareUpgradeItemParams, authInfo runtime.ClientAuthInfoWriter) (*CreateClusterFirmwareUpgradeItemOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateClusterFirmwareUpgradeItemParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createClusterFirmwareUpgradeItem",
		Method:             "POST",
		PathPattern:        "/platform/3/upgrade/cluster/firmware/upgrade",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateClusterFirmwareUpgradeItemReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateClusterFirmwareUpgradeItemOK), nil

}

/*
CreateClusterPatchAbortItem Abort the previous action performed by the patch system.
*/
func (a *Client) CreateClusterPatchAbortItem(params *CreateClusterPatchAbortItemParams, authInfo runtime.ClientAuthInfoWriter) (*CreateClusterPatchAbortItemOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateClusterPatchAbortItemParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createClusterPatchAbortItem",
		Method:             "POST",
		PathPattern:        "/platform/3/upgrade/cluster/patch/abort",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateClusterPatchAbortItemReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateClusterPatchAbortItemOK), nil

}

/*
CreateClusterPatchPatch Install a patch.
*/
func (a *Client) CreateClusterPatchPatch(params *CreateClusterPatchPatchParams, authInfo runtime.ClientAuthInfoWriter) (*CreateClusterPatchPatchOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateClusterPatchPatchParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createClusterPatchPatch",
		Method:             "POST",
		PathPattern:        "/platform/3/upgrade/cluster/patch/patches",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateClusterPatchPatchReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateClusterPatchPatchOK), nil

}

/*
CreateClusterRetryLastActionItem Retry the last upgrade action, in-case the previous attempt failed.
*/
func (a *Client) CreateClusterRetryLastActionItem(params *CreateClusterRetryLastActionItemParams, authInfo runtime.ClientAuthInfoWriter) (*CreateClusterRetryLastActionItemOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateClusterRetryLastActionItemParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createClusterRetryLastActionItem",
		Method:             "POST",
		PathPattern:        "/platform/3/upgrade/cluster/retry_last_action",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateClusterRetryLastActionItemReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateClusterRetryLastActionItemOK), nil

}

/*
CreateClusterRollbackItem Rollback the upgrade of a cluster.
*/
func (a *Client) CreateClusterRollbackItem(params *CreateClusterRollbackItemParams, authInfo runtime.ClientAuthInfoWriter) (*CreateClusterRollbackItemOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateClusterRollbackItemParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createClusterRollbackItem",
		Method:             "POST",
		PathPattern:        "/platform/3/upgrade/cluster/rollback",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateClusterRollbackItemReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateClusterRollbackItemOK), nil

}

/*
CreateClusterUpgradeItem The settings necessary to start an upgrade.
*/
func (a *Client) CreateClusterUpgradeItem(params *CreateClusterUpgradeItemParams, authInfo runtime.ClientAuthInfoWriter) (*CreateClusterUpgradeItemOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateClusterUpgradeItemParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createClusterUpgradeItem",
		Method:             "POST",
		PathPattern:        "/platform/3/upgrade/cluster/upgrade",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &CreateClusterUpgradeItemReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateClusterUpgradeItemOK), nil

}

/*
DeleteClusterPatchPatch Uninstall a patch.
*/
func (a *Client) DeleteClusterPatchPatch(params *DeleteClusterPatchPatchParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteClusterPatchPatchNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteClusterPatchPatchParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteClusterPatchPatch",
		Method:             "DELETE",
		PathPattern:        "/platform/3/upgrade/cluster/patch/patches/{ClusterPatchPatchId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DeleteClusterPatchPatchReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteClusterPatchPatchNoContent), nil

}

/*
GetClusterFirmwareProgress Cluster wide firmware upgrade status info.
*/
func (a *Client) GetClusterFirmwareProgress(params *GetClusterFirmwareProgressParams, authInfo runtime.ClientAuthInfoWriter) (*GetClusterFirmwareProgressOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetClusterFirmwareProgressParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getClusterFirmwareProgress",
		Method:             "GET",
		PathPattern:        "/platform/3/upgrade/cluster/firmware/progress",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetClusterFirmwareProgressReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetClusterFirmwareProgressOK), nil

}

/*
GetClusterFirmwareStatus The firmware status for the cluster.
*/
func (a *Client) GetClusterFirmwareStatus(params *GetClusterFirmwareStatusParams, authInfo runtime.ClientAuthInfoWriter) (*GetClusterFirmwareStatusOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetClusterFirmwareStatusParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getClusterFirmwareStatus",
		Method:             "GET",
		PathPattern:        "/platform/3/upgrade/cluster/firmware/status",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetClusterFirmwareStatusReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetClusterFirmwareStatusOK), nil

}

/*
GetClusterNode The node details useful during an upgrade or assessment.
*/
func (a *Client) GetClusterNode(params *GetClusterNodeParams, authInfo runtime.ClientAuthInfoWriter) (*GetClusterNodeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetClusterNodeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getClusterNode",
		Method:             "GET",
		PathPattern:        "/platform/3/upgrade/cluster/nodes/{ClusterNodeId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetClusterNodeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetClusterNodeOK), nil

}

/*
GetClusterNodes View information about nodes during an upgrade, rollback, or pre-upgrade assessment.
*/
func (a *Client) GetClusterNodes(params *GetClusterNodesParams, authInfo runtime.ClientAuthInfoWriter) (*GetClusterNodesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetClusterNodesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getClusterNodes",
		Method:             "GET",
		PathPattern:        "/platform/3/upgrade/cluster/nodes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetClusterNodesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetClusterNodesOK), nil

}

/*
GetClusterPatchPatch View a single patch.
*/
func (a *Client) GetClusterPatchPatch(params *GetClusterPatchPatchParams, authInfo runtime.ClientAuthInfoWriter) (*GetClusterPatchPatchOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetClusterPatchPatchParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getClusterPatchPatch",
		Method:             "GET",
		PathPattern:        "/platform/3/upgrade/cluster/patch/patches/{ClusterPatchPatchId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetClusterPatchPatchReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetClusterPatchPatchOK), nil

}

/*
GetUpgradeCluster Cluster wide upgrade status info.
*/
func (a *Client) GetUpgradeCluster(params *GetUpgradeClusterParams, authInfo runtime.ClientAuthInfoWriter) (*GetUpgradeClusterOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetUpgradeClusterParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getUpgradeCluster",
		Method:             "GET",
		PathPattern:        "/platform/3/upgrade/cluster",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetUpgradeClusterReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetUpgradeClusterOK), nil

}

/*
ListClusterPatchPatches List all patches.
*/
func (a *Client) ListClusterPatchPatches(params *ListClusterPatchPatchesParams, authInfo runtime.ClientAuthInfoWriter) (*ListClusterPatchPatchesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListClusterPatchPatchesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "listClusterPatchPatches",
		Method:             "GET",
		PathPattern:        "/platform/3/upgrade/cluster/patch/patches",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &ListClusterPatchPatchesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListClusterPatchPatchesOK), nil

}

/*
UpdateClusterUpgrade Add nodes to a running upgrade.
*/
func (a *Client) UpdateClusterUpgrade(params *UpdateClusterUpgradeParams, authInfo runtime.ClientAuthInfoWriter) (*UpdateClusterUpgradeNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateClusterUpgradeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "updateClusterUpgrade",
		Method:             "PUT",
		PathPattern:        "/platform/3/upgrade/cluster/upgrade",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &UpdateClusterUpgradeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UpdateClusterUpgradeNoContent), nil

}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
